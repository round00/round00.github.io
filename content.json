{"pages":[],"posts":[{"title":"新篇章","text":"终于搭好自己的博客了。之前的工作和学习过程中多多少少也记录了一些东西，但是没有系统的整理，文档东放一个西放一个。从现在开始要养成一个系统的、总结记录的好习惯。 FLAG立个Flag： 坚持打Codeforces或者Topcoder，并且在完成后写总结。 对学到的新东西的写文章记录。 坚持记录总结工作中遇到的比较通用的问题。 这样也能锻炼一下自己的文字能力，同时也给自己一点压力，逐渐养成一个良好的习惯。","link":"/2020/05/12/Beginning/"},{"title":"PostGIS实战-第三章 组织空间数据","text":"本章会介绍你可以设计的表布局来存储空间数据。然后给出一个对真实世界中城市建模的例子。最后讨论使用规则和触发器来管理表和视图的插入和更新。 一、空间存储方法在数据库设计时有很多需要考虑的因素，例如：所需要支持的分析特性、查询的速度、等等。对于空间数据库，在设计过程中还有一些附加的考虑因素： 数据的可用性 存储数据的精度 需要兼容什么地图工具 不像在普通数据库中，如果设计差一点的话，可能就是查询慢一点。在空间数据库中，如果设计的不好，可能一个查询在你这辈子都跑不完。最开始数据库设计的越好，之后就越少绕弯路。 在本节中会介绍三种通用的空间数据库中组织数据的方式： 异构几何类型列 同构几何类型列 表继承 接下来会介绍如何使用它们，以及各自的优劣势。 1、异构几何类型列这种方式不用考虑约束列为某种特定的几何类型。其实应该就是上一章中所说的geometrycollections。但是使用这种通用的几何列，并不意味着没有任何附加约束。仍然应该审慎地保证数据是完好的。建议强制使得空间参考系和空间维度一致。 使用这种方法的优点： 允许你对感兴趣的特征执行一个单独的查询，而不用放弃使用最合适的几何类型对它们进行建模。 简单。可以把非空间属性相同或不同所有的几何对象放到一个表中。 创建一个表很快，可以直接在创建表语句中指定几何列，而不用再调用AddGeo…函数。在你需要迭代的从非常多的表中加载数据并且你不知道它们包含的几何类型是怎么样的时候，尤为方便。 缺点： 存在可能将不合适的几何类型加入到一个对象中的风险。如果没有空间参考系或者维度的约束，之后的查询可能会出错。 许多第三方工具不能处理这种列。 在一些场景下，你只需要导出某种类型的几何对象，此时只能不断的对几何类型进行过滤。在表很大的情况下，这种行为会很慢，并且需要不断重复的去做。 把所有的几何数据丢到一个表里，可能会导致许多笨拙的自连接。例如一个表里既存放兴趣点，也存放多边形。当需要验证点是否在多边形中时，就需要将这个表和自己连接，然后再一次判断。如果点的个数是n，多边形的个数是m，那就是自连接的个数就是（n+m）（n+m）。而如果分开两个表来存放，那么连接的个数就是n\\m。 2、同构几何类型列这种方法避免了在同一个几何列中存在不同的几何对象。对一个城市建模时，可能有如下的方案： 把所有几何对象放在一个表中，这个表有四列：名称、点、线串、多边形。 把所有几何对象放在不同的表中，有三个表：名称+点、名称+线串、名称+多边形。 接下来也看看这种方法的优缺点： 优点： 强制保证了一致性，避免了无心的几何类型混合。 第三方工具依赖于几何对象的一致性。 在表连接的时候，会有更好的性能。 在需要画不同类型的几何对象时，将不同的几何对象放到不同的表中效率会更高。 在处理巨大的数据集的时候，分表可以使得让你享受将数据分别放在不同的物理磁盘上的好处。 PostgreSQL的表空间：它是一个物理的文件夹位置，而schema是上逻辑的。默认情况下，创建的所有表都会放到同一个表空间里。随着表大小的不断增加，可以创建额外的表空间，使你的表们分布在不同的表空间，即分布在不同的磁盘上，从而能使得磁盘的IO速率最大化。 缺点： 当你需要查询多种类型的几何对象时，你必须重新排序到一个合并的查询中。这样会增加查询的复杂度、降低速度。 如果你在一个表中放多个几何列，会有性能问题。这样会使表中的行更加臃肿，从而会使查询更慢，在select和update时都是这样。 3、表继承表继承是目前为止最多功能的一种方法，但是也更加复杂一点。pgsql的一个独一无二的功能是提供了表继承。可以利用这一特性，来获得前面两种方法的优点。表继承的意思是一个表可以继承父表的结构。父表不需要存储任何数据，而是将数据存储到子表当中。在这种情况下，父表常常被看做是抽象表，类似于面向对象的抽象类。子表继承父表的所有列，并且子表可以由自己的列。这些列只有当直接查询子表的时候才会展示出来。检查约束会被继承。主键和外键约束不会被继承。PostgreSQL支持多继承，子表可以继承多个父表，并且也不会限制继承的层数。 为了实现表继承这种存储方式，可以创建一个抽象表来根据非几何属性组织数据。然后创建子表来约束几何类型。在这种模式下可以查询父表然后看到所有子表的数据。或者当只需要某个几何类型时只查询某个子表。例如，创建一个父表来组织多种多样的几何类型，创建子表来存储某一种类型的几何对象。这样当我们不关心几何类型时，就从父表查询，否则从子表查询。目前为止，只有PostgreSQL支持这种优雅的方法。 约束排除：PostgreSQL有一个配置选项叫做约束排除，经常和表继承结合使用。当开启了这个选项的时候，查询会检查表约束然后决定在查询中是否跳过这个表。 使用这种方式的优缺点： 优点： 你可以查询一个有继承结构的表就好像它是一个表一样。或者在有需要时分开查询。 如果按照几何类型分割，可以根据需要查询某一特定的几何类型或者查询所有几何类型。 使用约束排除，查询可以聪明的跳过那些没有一行能满足过滤条件的表。 继承可以随时设置或者取消，使得执行数据加载更加方便。 很多第三方工具可以把父表看做是一个拥有完好的域的表，即使这个表中没有任何和几何相关的列。并且表继承和一些第三方工具，例如OpenJUMP、GeoServer等可以很好的合作。 缺点： 表继承不被其他一些主要的数据库所支持。如果想切换到其他数据库，你之前的代码可能会有问题。 主键和外键约束不会传递到子表。 为了维护继承关系，在添加数据的时候需要额外的操作来保证数据被恰当的添加到了父表或者某个子表中。在表更新的时候，你可能想当然的认为一个子表中的记录会自动的移动到另一个表中，但是这种情况会造成检查冲突。这意味着必须创建规则或者触发器。 是否应该完全使用约束排除来跳过一个表。在第一次执行查询的时候，会有性能问题。 注意继承结构中表的总数量，当有几百张表的时候，性能会显著下降。 接下来给出一个例子，来展示如何使用表继承建模。 12345678910111213141516171819202122-- 创建父表CREATE TABLE roads( gid serial PRIMARY KEY, road_name character varying(100));-- 为父表添加一个几何列SELECT AddGeometryColumn(&apos;public&apos;, &apos;roads&apos;, &apos;geom&apos;, 4269, &apos;LINESTRING&apos;,2);-- 创建子表CREATE TABLE roads_NE( CONSTRAINT pk PRIMARY KEY(gid)) INHERITS(roads);-- 给子表添加约束，使得该子表中的内容都是在指定范围内的ALTER TABLE roads_NE ADD CONSTRAINT chk CHECK( state IN (&apos;MA&apos;, &apos;ME&apos;, &apos;NH&apos;, &apos;VT&apos;, &apos;CT&apos;, &apos;RI&apos;) );CREATE TABLE roads_SW( CONSTRAINT pk PRIMARY KEY (gid)) INHERITS (roads);ALTER TABLE roads_SW ADD CONSTRAINT chk CHECK ( state IN (&apos;AZ&apos;, &apos;NM&apos;, &apos;NV&apos;) );-- 一个简单的查询，由于上面约束的存在，只会查询roads_NE子表，另外一个子表被过滤了SELECT gid, road_name, geom FROM roads WHERE state = &apos;MA&apos;; 以上就介绍完了三种空间存储方法。 二、对一个真实的城市建模在本节，以巴黎为例对一个城市建模，使用我们之前介绍的方法。这个城市被分为20个行政区划，如下图所示。 我们把每个区域建模为一个多边形容器，并且把它们插入到一个arrondissements表中。 在书上并没有看到加载数据的具体方法，不过在数据文件中介绍了一下，下面给出加载数据的过程。 首先，加载ch03.arrondissements表： 12-- 先创建一个临时schemaCREATE SCHEMA staging; 1234#先用shp2pgsql把数据加载到staging.paris_arrondissements表中。shp2pgsql -s 4326 /tmp/postgis/ch03/paris_-_arrondissements.shp staging.paris_arrondissements | psql -h localhost -U postgres -p 4096 test#在执行load.sql脚本把对数据进行转换psql -d test -U postgres -p 4096 -f /tmp/postgis/ch03/loading.sql 然后，使用psql加载planet_osm_line.sql、planet_osm_point.sql和planet_osm_polygon.sql 脚本： 1psql -d test -U postgres -p 4096 -f /tmp/postgis/ch03/planet_osm_line.sql 1psql -d test -U postgres -p 4096 -f /tmp/postgis/ch03/planet_osm_point.sql 1psql -d test -U postgres -p 4096 -f /tmp/postgis/ch03/planet_osm_polygon.sql 这里会把osm数据加载到public schema中，而不是ch03。本来我想修改一下sql脚本直接加载到ch03中，但是我看书上后续的代码都是基于osm数据在public schema中的，所有就这样吧。 1、使用异构几何列建模如果我们主要是按照区域来查找，而不考虑其中的几何类型的话，使用这种建模方式是最方便的。接下来创建表： 12345678910CREATE TABLE ch03.paris_hetero( gid serial NOT NULL, osm_id integer, geom geometry, ar_num integer, tags hstore, CONSTRAINT paris_hetero_pk PRIMARY KEY(gid), CONSTRAINT enforce_dims_geom CHECK (ST_NDims(geom) = 2), CONSTRAINT enforce_srid_geom CHECK (ST_SRID(geom) = 32631)); 在执行这份SQL代码的时候，提示了hstore没有安装。在网上搜索了一下，其实在PostgreSQL的源码中是有hstore的源码的，进入PostgreSQL源码/contrib/hstore目录下执行 make &amp;&amp; make install后，再在psql或者pgAdmin中执行create extension hstore;就可以了。 ar_num保存区域代号。hstore是用来存储键值对的数据类型。也可以使用GIST进行索引。在这里我们增加了两个约束：几何维度为2，SRID为32631。 ar_num这个属性并没有被OSM数据维护，但是可以通过对OSM数据和区域表求交来计算出这个属性。下面的代码展示了这个操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243INSERT INTO ch03.paris_hetero(osm_id, geom, ar_num, tags) SELECT o.osm_id, ST_Intersection(o.geom, a.geom) AS geom, a.ar_num, o.tags FROM (SELECT osm_id, ST_Transform(way, 32631) AS geom, tags FROM planet_osm_line) AS o INNER JOIN ch03.arrondissements AS a ON ST_Intersects(o.geom, a.geom);INSERT INTO ch03.paris_hetero(osm_id, geom, ar_num, tags) SELECT o.osm_id, ST_Intersection(o.geom, a.geom) AS geom, a.ar_num, o.tags FROM (SELECT osm_id, ST_Transform(way, 32631) AS geom, tags FROM planet_osm_polygon) AS o INNER JOIN ch03.arrondissements AS a ON ST_Intersects(o.geom, a.geom);INSERT INTO ch03.paris_hetero(osm_id, geom, ar_num, tags) SELECT o.osm_id, o.geom, a.ar_num, o.tags FROM (SELECT osm_id, ST_Transform(way, 32631) AS geom, tags FROM planet_osm_point) AS o INNER JOIN ch03.arrondissements AS a ON ST_Intersects(o.geom, a.geom);-- 创建索引CREATE INDEX idx_paris_hetero_geom ON ch03.paris_hetero USING gist(geom);CREATE INDEX idx_paris_hetero_tags ON ch03.paris_hetero USING gist(tags);-- 更新统计数据VACUUM ANALYZE ch03.paris_hetero; 这样在同一个表的一列中就放入了多种几何类型。下面这份代码，查询同一个区域中不同的特征地点的个数： 123SELECT ar_num, COUNT(DISTINCT osm_id) AS compte FROM ch03.paris_heteroGROUP BY ar_num; 下面是这个例子中的几个hstore数据的样子： 12345&quot;name&quot;=&gt;&quot;RER A&quot;, &quot;layer&quot;=&gt;&quot;-6&quot;, &quot;tunnel&quot;=&gt;&quot;yes&quot;, &quot;railway&quot;=&gt;&quot;rail&quot;, &quot;z_order&quot;=&gt;&quot;-65&quot;, &quot;operator&quot;=&gt;&quot;RATP&quot;&quot;ref&quot;=&gt;&quot;FR-RER A&quot;, &quot;route&quot;=&gt;&quot;light_rail&quot;, &quot;z_order&quot;=&gt;&quot;0&quot;, &quot;operator&quot;=&gt;&quot;RATP&quot;, &quot;route_name&quot;=&gt;&quot;Boissy-St-Léger--Saint-Germain-en-Laye&quot;, &quot;description&quot;=&gt;&quot;RER A A2-&gt;A1&quot;, &quot;route_pref_color&quot;=&gt;&quot;0&quot;&quot;name&quot;=&gt;&quot;Rue Copernic&quot;, &quot;oneway&quot;=&gt;&quot;yes&quot;, &quot;highway&quot;=&gt;&quot;residential&quot;, &quot;z_order&quot;=&gt;&quot;3&quot; 使用hstore类型的主要好处是，你不用为杂项属性操心，不用为它们创建一些很不常用的列。但是缺点也很明显，你无法像查询字符串或者数值列那样进行简单的查询。 注意：hstore是PostgreSQL的一个数据类型。 关于上面所说的缺点的一个简单的克服办法是：创建一个视图，来讲hstore属性映射到虚拟的属性列中。下面是创建这样视图的例子： 123456CREATE OR REPLACE VIEW ch03.vw_paris_points ASSELECT gid, osm_id, ar_num, geom, tags-&gt;&apos;name&apos; AS place_name, -- 将和store中的name键提取出来生成一个新的列 tags-&gt;&apos;tourism&apos; AS tourist_attractionFROM ch03.paris_heteroWHERE GeometryType(geom) = &apos;ST_Point&apos;; 2、使用同构几何列建模使用这种方式，我们会把每个不同的几何类型存储到它自己的一个列或者表中。这种存储方式比异构的更通用。是第三方工具支持最多的一种方式。根据几何类型来区分不同的列或者表，允许你进行强制几何类型约束，防止不经意间的类型的混淆。 下面的代码，将之前的异构的表中的数据拆分成同构的表。 1234567891011121314151617181920-- 创建一个表用于存储点CREATE TABLE ch03.paris_points( gid SERIAL PRIMARY KEY, osm_id integer, ar_num integer, feature_name varchar(200), feature_type varchar(50));-- 注册几何列，约束该几何列只存储点。这个约束是同构方式的关键。SELECT AddGeometryColumn(&apos;ch03&apos;, &apos;paris_points&apos;, &apos;geom&apos;, 32631, &apos;POINT&apos;, 2);-- 从之前的表中，将数据提取出来，插入到新建的表中。INSERT INTO ch03.paris_points( osm_id, ar_num, geom, feature_name, feature_type)SELECT osm_id, ar_num, geom, tags-&gt;&apos;name&apos; AS feature_name, COALESCE(tags-&gt;&apos;tourism&apos;, tags-&gt;&apos;railway&apos;, &apos;other&apos;)::varchar(50) AS feature_typeFROM ch03.paris_heteroWHERE ST_GeometryType(geom) = &apos;ST_Point&apos;; 1234567891011121314151617181920-- 创建一个表用于存储多边形CREATE TABLE ch03.paris_polygons( gid SERIAL PRIMARY KEY, osm_id integer, ar_num integer, feature_name varchar(200), feature_type varchar(50));-- 注册几何列，约束该几何列只存储多边形。这个约束是同构方式的关键。SELECT AddGeometryColumn(&apos;ch03&apos;, &apos;paris_polygons&apos;, &apos;geom&apos;, 32631, &apos;POLYGON&apos;, 2);-- 从之前的表中，将数据提取出来，插入到新建的表中。INSERT INTO ch03.paris_polygons( osm_id, ar_num, geom, feature_name, feature_type)SELECT osm_id, ar_num, geom, tags-&gt;&apos;name&apos; AS feature_name, COALESCE(tags-&gt;&apos;tourism&apos;, tags-&gt;&apos;railway&apos;, &apos;other&apos;)::varchar(50) AS feature_typeFROM ch03.paris_heteroWHERE ST_GeometryType(geom) = &apos;ST_Polygon&apos;; 1234567891011121314151617181920-- 创建一个表用于存储线串CREATE TABLE ch03.paris_linestrings( gid SERIAL PRIMARY KEY, osm_id integer, ar_num integer, feature_name varchar(200), feature_type varchar(50));-- 注册几何列，约束该几何列只存储线串。这个约束是同构方式的关键。SELECT AddGeometryColumn(&apos;ch03&apos;, &apos;paris_linestrings&apos;, &apos;geom&apos;, 32631, &apos;LINESTRING&apos;, 2);-- 从之前的表中，将数据提取出来，插入到新建的表中。INSERT INTO ch03.paris_linestrings( osm_id, ar_num, geom, feature_name, feature_type)SELECT osm_id, ar_num, geom, tags-&gt;&apos;name&apos; AS feature_name, COALESCE(tags-&gt;&apos;tourism&apos;, tags-&gt;&apos;railway&apos;, &apos;other&apos;)::varchar(50) AS feature_typeFROM ch03.paris_heteroWHERE ST_GeometryType(geom) = &apos;ST_LineString&apos;; 下面是和之前的相同的一个例子，查询同一个区域中不同的特征地点的个数： 123456789SELECT ar_num, COUNT(DISTINCT osm_id) AS compteFROM ( SELECT ar_num, osm_id FROM ch03.paris_points UNION ALL SELECT ar_num, osm_id FROM ch03.paris_polygons UNION ALL SELECT ar_num, osm_id FROM ch03.paris_linestrings )AS X -- 这个别名不能少。GROUP BY ar_num; 可以看到，在同构方法时， 需要分别把每个单独的表中的数据都提取出来合并到一起，在进行之后的操作。 UNION和UNION ALL的区别： UNION会隐式的执行去重操作，而UNION ALL不会，是全部合并到一起。如果你知道你的数据集不能或者不需要去重的话，就用UNION ALL吧，它肯定会更快一些。 3、使用表继承建模","link":"/2020/05/16/postgis-in-action-ch3/"},{"title":"Codeforces Round 642 (Div. 3)","text":"这场比赛当时有事没有参加，是后面补的。 Div3难度较低，但是由于很久没做过了，两个小时只做了4题。E题写错了，F题看都没看。过后看了题解才过的。 题目链接：Codeforces Round #642 (Div. 3) A. Most Unstable Array题目描述的比较玄乎，但是写几个例子之后就会发现一个很简单的规律，分以下几种情况来说： n&gt;2时：只要把m放到一个随意的中间的位置，其他位置都是0。这样，m这个数会被前后两个0组合到一起计算两次，结果就是2*m。关于是否是最优解的证明就一细说了，可以这样想一下，如果把m拆开分到不同的位置，那么每个数也是最多会被计算两次。 n=2时：把m放到其中一个位置，另一个位置放0。结果是m。 n=1时：结果是0。 代码如下： 12345678910111213141516int main(){// freopen(&quot;in&quot;, &quot;r&quot;, stdin); int T;scanf(&quot;%d&quot;, &amp;T); while(T--){ int n,m;scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if(n==1){ printf(&quot;%d\\n&quot;, 0); }else if(n==2){ printf(&quot;%d\\n&quot;, m); }else { printf(&quot;%d\\n&quot;, 2*m); } } return 0;} B. Two Arrays And Swaps这个题目很好想。只要把数组a按照从小到大排序，数组b从大到小排序。然后把a和b的前k个数交换。再交换的时候要判断一下，如果a中的数比b中的数大的话就不用交换了。 1234567891011121314151617181920212223242526272829int main(){// freopen(&quot;in&quot;, &quot;r&quot;, stdin); int T;scanf(&quot;%d&quot;, &amp;T); while(T--){ int n,k;scanf(&quot;%d%d&quot;, &amp;n, &amp;k); vector&lt;int&gt; a, b; for(int i = 0; i&lt;n; ++i){ int t;scanf(&quot;%d&quot;, &amp;t); a.push_back(t); } for(int i = 0; i&lt;n; ++i){ int t;scanf(&quot;%d&quot;, &amp;t); b.push_back(t); } sort(a.begin(), a.end()); sort(b.begin(), b.end(), [](int x, int y){ return x&gt;y; }); for(int i = 0;i&lt;k; ++i){ if(a[i]&lt;b[i]) swap(a[i], b[i]); } int sum = 0; for(int i = 0;i&lt;n; ++i)sum += a[i]; printf(&quot;%d\\n&quot;, sum); } return 0;} C. Board Moves题意可以理解为：给出一个棋盘，棋盘的每个格子中有一个棋子。然后把所有的棋子都移动到最中间的位置需要多少步。这个题只要画个棋盘的图，然后计算一个样例就找到规律了。从最中间的那个格子往外扩散，每相同的一圈，需要的步数都是相同的，分别是1、2、3…步。这样，只需要数出每一圈有多少个格子，然后将结果加起来即可。 12345678910111213141516using LL = long long;int main(){// freopen(&quot;in&quot;, &quot;r&quot;, stdin); int T;scanf(&quot;%d&quot;, &amp;T); while(T--){ LL n;cin&gt;&gt;n; LL ans = 0, base = 8; for(LL i = 3; i&lt;=n; i+=2){ ans += base * ((i-1)/2); base += 8; } cout&lt;&lt;ans&lt;&lt;endl; } return 0;} 记得用64位，会超int。 D. Constructing the Array题意是给一个n，取值范围[1, 2e5]。然后根据指定的规则构造出一个长度为n的数组，这个数组存在且唯一。输出这个数组。 最开始我还在想这个题是不是有什么trick，想了好久都白给。后来觉得浪费时间太多了，还是想想有没有暴力的方法吧。然后发现用BFS构造出数组不就行了么。遂写之。 最开始想的BFS的思路是：每次把当前的区间加入到队列中，然后根据当前区间确定出一个位置的值。然后再分割成两个子区间，把两个子区间按照一定的顺序加入到BFS队列中。 后来测试时发现，这样并不能保证区间顺序的正确性，还是要使用优先队列，先按照区间长度从大到小，再按照区间左边界从小到大，插入到优先队列中。这样就能保证顺序的正确性了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct node{ int l; int r;};struct cmp{ bool operator()(const node&amp; a, const node&amp; b){ if(a.r-a.l == b.r-b.l)return a.l&gt;b.l; return a.r-a.l&lt;b.r-b.l; }};int main(){// freopen(&quot;in&quot;, &quot;r&quot;, stdin); int T;scanf(&quot;%d&quot;, &amp;T); while(T--){ int n;scanf(&quot;%d&quot;, &amp;n); priority_queue&lt;node, vector&lt;node&gt;, cmp&gt; q; vector&lt;int&gt; ans(n, 0); int cur = 1; q.push({1, n}); while(!q.empty()){ node t = q.top();q.pop(); int mid; if((t.r-t.l+1)%2){ mid = (t.r+t.l)/2; if(mid&gt;t.l){ q.push({t.l, mid-1}); q.push({mid+1, t.r}); } }else{ mid = (t.r+t.l-1)/2; q.push({mid+1, t.r}); if(mid&gt;t.l){ q.push({t.l, mid-1}); } } ans[mid-1] = cur++; } for(auto x:ans){ printf(&quot;%d &quot;, x); } printf(&quot;\\n&quot;); } return 0;} 这里在优先队列的使用方法上卡了一会，这个东西的使用还是不熟练。 我在看高分选手代码时，发现直接使用set&lt; pair&lt;int, pair&lt;int,int&gt;&gt; &gt;就行了。这个我没有用过，不过根据set有序的原理，应该是会先按照pair的first排序，再按照pair的second排序这样子。 E. K-periodic Garland题意：给一个01字符序列，表示一串灯的状态，0表示关，1表示开。然后规定，如果序列中每两个相邻的打开的灯的距离恰好是指定的k的话，那这个灯的序列就是好的。 问：最少需要改变多少个灯的状态，使得序列变为好的。 这个题没有做出来，当时想了一个暴力贪心的方法。但是第二组数据就直接挂了。赛后看了题解和第一名的代码。前者是dp，后者是模拟+贪心+枚举。但是想法都差不多。我选择了后者的思路，感觉他的思路比较优雅。 首先，先这样想，如果最后的序列是好的，那么最后的结果一定是每隔k-1个0就跟着一个1。那么我们就可以可以根据初始和最后的状态，通过一些简单的计算得出需要修改状态的灯的个数。 然后，初始的状态是不变的，这个我们知道。但是最后的状态该怎么确定呢？枚举。我们可以根据最后的状态，把初始的序列分为两个子序列，一个子序列是最后都是1的灯的序列，即每隔k-1个0的序列。另一个子序列就是剩下的灯组成的序列。那么第一个子序列我们可以通过枚举[0,k)为起点，然后每次跳k个位置即可。这样原始的n个灯，每个会被访问一次，复杂度O(N)。 其次，知道最后的状态，那么怎么计算出需要关闭的灯的个数呢？如果用O(N)的时间去遍历一遍，那么总的复杂度会是O(N^2)，显然不行。这里就有一个关键的技巧了。首先我们可以先数出初始状态打开的灯的个数X。在枚举的子序列中，打开的灯的个数Y，关闭的灯的个数Z。并且在最后的状态中，除了我们枚举的子序列，其他位置的灯都应该是关闭的状态。那么在枚举的子序列中，需要把关闭的灯打开（这里先这样认为，后面再说个问题）。枚举的子序列之外的序列，需要全部关闭。则总的操作数应该是：X-Y+Z。-Y是因为这些灯本来就是开着的，不用操作。这样只需要在枚举的过程中维护需要的最小操作数就可以了。 最后，还有个问题：上面所说的X-Y+Z可能会有不必要的操作。例如111100000这个初始序列，最后都是0的且后面没有1的情况，我们没必要再把后面的灯打开了。这个问题的解决办法在代码里看吧。 123456789101112131415161718192021222324252627282930char s[1000005];int main(){// freopen(&quot;in&quot;, &quot;r&quot;, stdin); int T;scanf(&quot;%d&quot;, &amp;T); while(T--){ int n, k;scanf(&quot;%d%d&quot;, &amp;n, &amp;k); scanf(&quot;%s&quot;, s); int ones = 0; for(int i = 0;i&lt;n; ++i) if(s[i] == &apos;1&apos;) ones++; int ans = 1e9; for(int i = 0;i&lt;k; ++i){ int d = 0; for(int j = i; j&lt;n; j+=k){ if(s[j]==&apos;0&apos;)d++; else d--; //注意：这里需要在每次统计枚举的子序列中的灯的状态时，更新一次 //答案。这样能避免上面所说的最后一个问题。 //因为如果后面没有1，全都是0的话，d的值只会增大，不会减小。 //那么就不会导致最优解被覆盖。 d = min(0, d); ans = min(ans, ones+d); } } printf(&quot;%d\\n&quot;, ans); } return 0;} F. Decreasing Heights题意：给一个棋盘，棋盘中的每个格子都一定的高度。我们需要从（1,1）走到（n,m）。走的限制是： 每次只能向右或者向下走。 下一步的格子的高度必须要比当前格子高1个单位。 对于棋盘中的每个格子，可以对其进行操作，只能降低其高度。所有的格子都可以进行操作。 问：想要从（1,1）走到（n,m），需要降低的总的高度是多少。保证存在解。 这个题没做出来，赛后看的题解，直接说解题思路吧。 首先，我们假设棋盘下标是从（0,0）开始的。h[i,j]表示[i,j]这个格子的高度。还是从最终状态来说，如果要从（0,0）走到（i,j）那么一定有：h[i,j] - h[0,0] = i + j。那么如果我们确定了h[0,0]，就相当于是确定了其他格子的高度。这样，跑一遍dp，就能求出到（n,m）的最小代价了。 然后，如何确定h[0,0]呢？我们可以枚举它的值，但是高度的取值范围最大有1e15，显然不可能这样做。既然要枚举，很容易想到的可以从棋盘中某个原始的格子高度来推出(0,0)的高度。接下来证明这个方法的正确性。上面这个思路是基于一个结论：在确定了最终高度后，棋盘中存在某个格子的高度不变。用反正法，假设在确定了最终高度后，棋盘中所有的格子的高度都会被降低。我们需要的其实只是高度差最小，如果是这样的话，肯定存在一定的浪费。我们可以选择降低最少的一个格子，再把它“提高”回来。这样就又得到之前的正确结论。 代码如下： 12345678910111213141516171819202122232425262728293031using ll = long long;ll INF = 1e18;ll a[105][105];int main(){// freopen(&quot;in&quot;, &quot;r&quot;, stdin); int T;scanf(&quot;%d&quot;, &amp;T); while(T--){ int n, m;scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 0;i&lt;n; ++i)for(int j = 0;j&lt;m; ++j) cin&gt;&gt;a[i][j]; ll a00 = a[0][0], ans = INF; for(int l = 0; l&lt;n; ++l)for(int k = 0; k&lt;m; ++k){ //根据矩阵中的每一个高度，暴力枚举a[0][0]的初始值 a[0][0] = a[l][k] - l - k; if(a[0][0]&gt;a00)continue; //从这个位置推[0,0]得到的结果不合法 vector&lt;vector&lt;ll&gt;&gt; d(n, vector&lt;ll&gt;(m, INF)); d[0][0] = a00 - a[0][0]; for(int i = 0;i&lt;n; ++i)for(int j = 0;j&lt;m; ++j){ //dp ll tar = a[0][0] + i + j; if(a[i][j]&lt;tar)continue; //此路不通 if(i&gt;0)d[i][j] = min(d[i][j], d[i-1][j]+a[i][j]-tar); if(j&gt;0)d[i][j] = min(d[i][j], d[i][j-1]+a[i][j]-tar); } ans = min(ans, d[n-1][m-1]); } cout&lt;&lt;ans&lt;&lt;endl; } return 0;}","link":"/2020/05/16/codeforces-round-642/"},{"title":"PostGIS实战-第一章 什么是空间数据库","text":"尽管各种地图网站提供了前所未有的交互式地图，但是使用他们仍然需要用户收集数据点然后放到地图上。使用地图只能依靠用户的视觉感知，当数据量大后，维护起来很麻烦。 1、以空间思维思考空间数据库：是一个定义了用于存储几何对象的特殊数据类型，并且可以存储几何数据到常规数据库表中的数据库。它提供了特殊的函数和索引使得可以通过SQL语句来查询和操作几何数据。空间数据库常常仅用作存储空间数据的容器，但是它能做到的远远不止这些。尽管空间数据库本质上可以不是关系型数据库，但是大部分有名的都是。 空间数据库提供给你两个工具：存储工具和分析工具。 1.介绍几何数据类型二维地图可以通过三种基本几何对象来组成：点、线串、多边形。 仅仅使用这三种对象，你就能在二维空间对任何东西建模。 2、建模空间查询：使用数据库查询的几何函数来回答空间和空间中的对象的相关问题的查询。 3、介绍PostgreSQL和PostGISPostGIS是一个免费开源的库，它使得另一个免费开源的关系型对象数据库PostgreSQL空间可用。选择PostgreSQL作为PostGIS的开发平台的主要原因是：对创建新类型与操作和控制索引操作的易扩展性。 1. PostgreSQL它是一个拥有“皇族血统”的关系型对象数据库系统，可以追溯到关系数据库诞生的时候。独一无二的特性： 支持许多语言来写数据库函数 支持数组（然而Oracle、DB2也支持） 表继承，类似对象的多继承 定义处理多列的聚合函数的能力 还有一些企业级的高级特性。 2. PostGIS将GIS添加到PostgreSQL中。它是由Refractions Research带头的一个项目。支持300多种空间操作、函数、数据类型和空间索引增强实现。PostGIS可以通过包含其他项目支持来增强。OGC：开放式地理空间协会（Open Geospatial Consortium），它的存在是为了标准化地理和空间数据的获取和发布。它有许多的规格来统一：在web服务中获取地理空间数据、地理空间数据的分发格式、查询地理空间数据。 OSGeo：开源地理空间基金会（Open Source Geospatial Foundation），它倡议储备、支持、推销开源工具、免费化GIS数据 4、开始使用PostGIS1、安装此书使用的版本：PostGIS1.3 or higher，PostgreSQL8.2 or higher。在附录B有安装指南。或者中文博客上的安装教程： Windows：PostGIS教程二：PostGIS的安装_数据库_不睡觉的怪叔叔的博客-CSDN博客 CentOS：Linux（centos）中使用源码安装PostGIS_运维_不睡觉的怪叔叔的博客-CSDN博客 在CentOS上编译SFCGAL时遇到了c++: internal compiler error: Killed (program cc1plus这样的错误，最后查到应该是内存不足的原因，通过使用交换分区来解决，百度这个错误就能找到解决办法。手动安装PostGIS的过程很繁琐，需要小心的执行每个安装步骤。 我在我的windows电脑和centos7服务器上都安装了PostgreSQL+PostGIS。不过主要用服务器来运行数据库，使用Windows上面的pgAdmin来做实验。 安装完成后，在Windows上打开pgAdmin4，会在浏览器中打开一个pgAdmin4的页面，设置好服务器、数据库的连接。然后点击选中一个数据库，再点最页面上面的Tools菜单项，选择Query Tool，就会打开一个执行SQL语句的tab。接下来执行： 1SELECT postgis_full_version(); 如果输出了PostGIS依赖的各项插件的版本号，就说明安装成功了。查看PostgreSQL版本的命令是： 1SELECT version(); 注：再接下来的例子中，一般情况下也只会写出执行的SQL语句，而不给出它的输出结果的截图，只是因为太麻烦了。2、使用PostGIS创建几何对象首先以创建一个点为例子： 1SELECT ST_Point(1,2) as MyFirstPoint; 这样就会创建一个一个点(1, 2)。在这里我们并没有指定空间参考系，PostGIS默认空间参考系的是笛卡尔坐标系，也就是我们从小到大学的那种坐标系。但是在实际应用中指定空间参考系是非常重要的。PostGIS中有3000多个空间参考系（我实际查了一下，现在有5757个），由EPSG标准来给每一种参考系指定一个数字编号。可以在这个表中spatial_ref_sys查到，这个表好像是数据库自带的，不过我没有看到默认有这个，我是在之前的练习中导入数据时搞到的。接下来创建另一个点，这次指定了地理关联： 1SELECT ST_SetSRID(ST_Point(-77.036548, 38.895108),4326); 这里使用ST_SetSRID函数指定了这个点是使用4326这个空间参考系，而这个参考系就是我们所知道的经纬度参考系（WGS 84）。 ST_GeomFromText函数提供了一种更通用的，以文本形式来创建几何对象的方法。这个函数相比于ST_Point这种专门的函数，效率慢、精度低。但是好处是更加直观和通用，适用于所有的几何类型： 1SELECT ST_GeomFromText(&apos;POINT(-77.036548 38.895108)&apos;, 4326); 使用这个函数创建几何类型时，文本内容当然不是随意写的，必须按照一定的格式。这个格式叫做WKT(Well-Known Text)几何表示方式。这种格式是OGC标准规定的。在PostGIS中，ST_AsText和ST_GeomFromText提供相反的操作，来实现：几何类型&lt;-&gt;文本的转换。因为几何类型在数据库中是以二进制格式存储的，没有可读性。例如上面创建的对象可能是这个样子的： 10101000020E6100000FD2E6CCD564253C0A93121E692724340 使用ST_AsText或者ST_AsEWKT可以转换为文本格式。这两者之间略有不同，后者会多输出一个空间参考系的编号。 然后我们来创建一个线串： 1SELECT ST_GeomFromText(&apos;LINESTRING(-14 21,0 0,35 26)&apos;) AS MyCheckMark; 可以看到线串就是一些点的序列而已。创建多边形和线串类似，不过多边形需要是一个闭合的线串，或者说是一个环。下面这个语句创建了一个三角形： 1SELECT ST_GeomFromText(&apos;POLYGON((0 1,1 -1,-1 -1,0 1))&apos;) As MyTriangle; 下面这个语句创建了一个心形： 12SELECT ST_GeomFromText(&apos;POLYGON((52 218, 139 82, 262 207, 245 261, 207 267, 153 207, 125 235, 90 270, 55 244, 51 219, 52 218))&apos;) As HeartPolygon; 在多边型的表示中，比线串格式多了一对小括号。因为多边形中可能存在“洞”，所以多边形可能有多条线串。 以上就是创建几何对象的基本操作了。 5、使用实际数据在这一节会讲述如何从两种常见的格式来加载数据： 分隔的ASCII数据 ESRI图形文件数据 这里提一下几何类型和地理类型： 地理类型：必须以经纬度的方式(WSG 84，SRID=4326)存储，距离的度量单位是米。能够使用的PostGIS函数较少，且效率不高。 几何类型：可以以任何支持的空间参考系来存储，度量单位由空间参考系指定。能够使用的PostGIS函数多。 由于度量方式和计算方式不同，有时候必须在这两种类型之间进行转换。 1、加载以逗号分隔的数据数据来源是一些快餐店的数据信息。在开始加载数据之前，需要先创建schema和表来存储数据。 12345678910111213141516171819202122232425CREATE SCHEMA ch01;-- 创建快餐店名字和代号的映射表CREATE TABLE ch01.lu_franchises( franchise_code char(1) PRIMARY KEY, franchise_name varchar(100));-- 插入一些数据INSERT INTO ch01.lu_franchises(franchise_code, franchise_name)VALUES (&apos;b&apos;, &apos;Burger King&apos;), (&apos;c&apos;, &apos;Carl&apos;&apos;s Jr&apos;), (&apos;h&apos;, &apos;Hardee&apos;&apos;s&apos;), (&apos;i&apos;, &apos;In-N-Out&apos;), (&apos;j&apos;, &apos;Jack in the Box&apos;), (&apos;k&apos;, &apos;Kentucky Fried Chicken&apos;), (&apos;m&apos;, &apos;McDonald&apos;&apos;s&apos;), (&apos;p&apos;, &apos;Pizza Hut&apos;), (&apos;t&apos;, &apos;Taco Bell&apos;), (&apos;w&apos;, &apos;Wendy&apos;&apos;s&apos;);-- 创建快餐店位置的表CREATE TABLE ch01.fastfoods( franchise_code char(1) NOT NULL, lat double precision, lon double precision); 其中： schema是数据库实例下一层的一个概念，从逻辑上分割表、视图、函数这些对象。 创建店名和代号的查找表。 加入一些数据。 创建存储地理位置信息的表。 可以使用PostgreSQL的内置函数COPY或者psql的\\copy命令来将数据加载到数据库中。前者可以在任何可以运行SQL语句的客户端上使用，后者只能在psql客户端中使用。 使用COPY函数： 1COPY ch01.fastfoods FROM &apos;/tmp/postgis/ch01/fastfoods.csv&apos; DELIMITER &apos;,&apos;; 使用psql的\\copy命令： 1\\copy ch01.fastfoods from &apos;/data/fastfoods.csv&apos; DELIMITER AS &apos;,&apos; 这里要把路径替换成自己的。数据来源可以从本书网站上去下载。然后给fastfoods表添加一个主键： 1ALTER TABLE ch01.fastfoods ADD COLUMN ff_id SERIAL PRIMARY KEY; 2、空间化平面文件数据首先，先为fastfoods表创建几何对象列： 12345678-- 创建几何对象列SELECT AddGeometryColumn(&apos;ch01&apos;, &apos;fastfoods&apos;, &apos;geom&apos;, 2163, &apos;POINT&apos;, 2);-- 用现有的经纬度数据来创建对应的几何对象UPDATE ch01.fastfoods SET geom = ST_Transform( ST_GeomFromText(&apos;POINT(&apos; || lon || &apos; &apos; || lat || &apos;)&apos;, 4326), 2163);-- 为几何对象创建空间索引CREATE INDEX idx_fastfoods_geom ON ch01.fastfoods USING GIST(geom); 然后，再为fastfoods表创建地理对象列： 12345-- 这里使用PostgeSQL内置的特性来添加新列，而不是前面的AddGeo..函数ALTER TABLE ch01.fastfoods ADD COLUMN geog geography(POINT, 4326);UPDATE ch01.fastfoods SET geog = ST_GeogFromText(&apos;SRID=4326;POINT(&apos; || lon || &apos; &apos; || lat || &apos;)&apos;);CREATE INDEX idx_fastfoods_geog ON ch01.fastfoods USING GIST(geog); 一个良好的习惯，在执行批量加载操作后执行一次清理： 1vacuum analyze ch01.fastfoods; 清理操作会删除掉已经无用的列，并且更新统计信息。如果不显示调用的化，会由服务器上的vacuum守护进程定期清理。为了防止fastfoods表中的店名代号被错误添加或者修改，为它添加约束： 12345ALTER TABLE ch01.fastfoods ADD CONSTRAINT fk_fastfoods_franchise FOREIGN KEY (franchise_code) REFERENCES ch01.lu_franchises(franchise_code) ON UPDATE CASCADE ON DELETE RESTRICT; 这种语句其实不用记住背过，在图形界面下直接就能通过点点点来生成。 3、从空间数据源加载数据最常用的发布空间数据的格式是ESRI的图形文件格式。加载这种文件格式的数据时，在Windows上需要用到PostGIS 2.0 Shapefile and DBF Loader Exporter这个程序，它会随安装PostGIS时一块安装好。打开它后，需要以下几步操作： 点击View connection details设置好PostgreSQL数据库的信息。 在Import tab中点击Add File，选择.shp文件，然后修改schema为ch01和srid为4269。 在Options中把两个选中的选项去掉。 Import。 在Linux上可以使用pgsql安装目录下的shp2pgsql程序来加载： 1shp2pgsql -s 4269 -g geom_4268 /tmp/postgis/ch01/roadtrl020.shp ch01.roads | psql -h localhost -U postgres -p 4096 test 虽然这个命令很长，但是拆解开后还是很好理解的。完成后会在schema ch01创建下一个新表roads，这个表中包含导入的数据。这里指定的是SRID=4269，它和4326非常相似，在大部分情况下是可以替换使用的。接下来要把4269参考系转换为2163的： 1234SELECT AddGeometryColumn(&apos;ch01&apos;, &apos;roads&apos;, &apos;geom&apos;, 2163, &apos;MULTILINESTRING&apos;, 2);UPDATE ch01.roads SET geom = ST_Transform(geom_4268, 2163);SELECT DropGeometryColumn(&apos;ch01&apos;, &apos;roads&apos;, &apos;geom_4268&apos;);CREATE INDEX idx_roads_geom ON ch01.roads USING GIST(geom); 在这里把2163写成了2613，找错误找了贼久，一定要仔细啊。 在加载完成后不要忘记执行一次： 1VACUUM ANALYZE ch01.roads; 在可以在加载的时候选择直接加载为地理类型，在Windows上只需要把Options…中的Load intogeography column选中即可。 在Linux上执行： 1shp2pgsql -G -g geog /tmp/postgis/ch01/roadtrl020.shp ch01.roads_geog | psql -h localhost -U postgres -p 4096 test 和加载为几何类型时非常相似，只有少许改动。 6、使用空间查询分析数据到目前为止我们已经把数据加载到数据库中了，接下来使用标准统计SQL查询来分析数据。 1、邻近查询空间数据库的最常用方式之一就是查询对象的邻近性。接下来是一些练习问题：注：1英里=1609米 1）有多少连锁快餐店在主要的高速公路一英里范围内？注意：ST_DWithin函数对于几何类型和地理类型是都可以使用的。 123456789SELECT ft.franchise_name, COUNT(DISTINCT ff.ff_id) AS tot -- 数出每种快餐店出现了多少次，DISTINCT用于确保同一家店不会被计算两次FROM ch01.fastfoods AS ff INNER JOIN ch01.lu_franchises AS ft -- 非空间连接，根据代号找出对应的快餐店名 ON ff.franchise_code = ft.franchise_code INNER JOIN ch01.roads AS r -- 空间连接，找出在主干高速公路1英里范围内的快餐店 ON ST_DWithin(ff.geom, r.geom, 1069*1)WHERE r.feature LIKE &apos;Principal Highway%&apos; -- 定位主干高速公路GROUP BY ft.franchise_name -- 对查找出的结果，按照快餐店名字分组ORDER BY tot DESC; -- 按照出现次数降序排序 查询的结果如下： 2）哪条高速公路在半英里半径内，有最多数量的快餐店12345678SELECT r.name, COUNT(DISTINCT ff.ff_id) AS tot -- 数出每种快餐店出现了多少次，DISTINCT用于确保同一家店不会被计算两次FROM ch01.fastfoods AS ff INNER JOIN ch01.roads AS r -- 空间连接，找出在主干高速公路半英里范围内的快餐店 ON ST_DWithin(ff.geom, r.geom, 1069*0.5)WHERE r.feature LIKE &apos;Principal Highway%&apos; -- 定位主干高速公路GROUP BY r.name -- 对查找出的结果，按照高速公路名字分组ORDER BY tot DESC -- 按照出现次数降序排序LIMIT 5; -- 这里只给出前5条高速公路 查询的结果如下：结果中的null是没问题的，因为有些高速公路就是没有名字数据的。 2、使用OpenJUMP可视化数据PostGIS除了擅长于实现只查看地图不可能完成的快速空间分析，还可以可视化数据源，创建附加的适用于在地图上标记出关键区域的衍生出的几何对象。在PostGIS中经常用于可视化的一个函数是ST_Buffer。接下来是一个例子，用于找出高速公路US Route 1在MaryLand州这一段中，10英里范围内的Hardee快餐店有几家： 12345SELECT COUNT(DISTINCT ff.ff_id) AS totFROM ch01.fastfoods AS ff INNER JOIN ch01.roads AS r ON ST_DWithin(ff.geom, r.geom, 1609*10)WHERE r.name=&apos;US Route 1&apos; AND ff.franchise_code=&apos;h&apos; AND r.state=&apos;MD&apos;; 结果是3。 后面一些内容需要使用OpenJUMP才有效果，但是OpenJUMOP需要到12章才讲，所以这里先不写了。 7、总结在本章初步认识了空间关系数据库，以及它是怎么嵌入到关系数据库中的。提出了使用空间结构来对真实世界进行建模的思想。展示了PostgreSQL/PostGIS如何用于分析数据的空间模式。给出了几个简单的例子来展示PostGIS的用法。","link":"/2020/05/16/postgis-in-action-ch1/"},{"title":"PostGIS实战-第二章 几何类型","text":"本节会解释PostGIS是如何管理在数据库中存储的几何数据的。 1、PostGIS中的几何列PostGIS对pgsql进行扩展，引入了几何数据类型。并且可以把几何数据类型和pgsql中的原生数据类型同等对待。pgsql有自己原生的几何数据类型，但它们和PostGIS是不兼容的，并且也没有第三方的可视化支持。这些原生几何类型自pgsql诞生起就存在了，但是它们并不遵从OpenGIS联合体的标准，也不支持空间坐标系。 1、geometry_columns表PostGIS使用一个叫做geometry_columns的表来存储在当前数据库中的和几何列相关联的元数据。这些元数据一般是被第三方工具用来收集数据库中的几何层信息的。当被展示到地图应用程序时，空间表中的几何列常常被解释为层或者特征类。这个表中有七列，分别是： f_table_catalog：数据库名 f_table_schema：schema名 f_table_name：表名 f_geometry_column：几何列名 coord_dimension：几何坐标维度-2,3,4维 SRID：空间参考系ID type：几何对象的类型 其中： 坐标维度最多支持到4维，并且第4维并不是空间的，而常常被当做是M(measure)坐标。PostGIS中所有的几何操作都把第四维看做是额外的属性，而不是空间维度。例如时间维度。 SRID是空间参考系标识符，是一个整数，可以在spatial_ref_sys表中查到对应的相关信息，并且它是该表的主键。还有另外一种表示方法叫做SRS ID，由作者名+唯一表示符来表示。例如，SRID=4326表示经纬度空间参考系，使用SRS ID表示法是EPSG:4326。其中EPSG是一个标准组织的名字。即使使用不同的SRID，也不能改变POSTGIS下层空间参考系是矩形笛卡尔系的事实。当处理地理类型时，这个问题会突显出来。在OGC标准中，未知的SRID用0表示。我们也可以自己定义空间参考系然后加入到 spatial_ref_sys表中 type的值可以是：POINT、LINESTRING、PLOYGON、MULTIPOINT、….、GEOMETRY这些。 强烈建议：不要直接修改geometry_columns表。 2、和geometry_columns表交互为了避免直接修改geometry_columns表，PostGIS提供了五个函数来和geometry_columns表交互： AddGeometryColumn：添加一个几何列到指定表中，并且添加相关元信息到eometry_columns表。 DropGeometryTable：删除一个表中的几何列。 UpdateGeometrySRID：更新表中几何列的SRID。例如当写错了SRID时，可以用这个来修正。 Probe_Geometry_Columns：它不会销毁任何geometry_columns表中已经存在的信息，而只是添加有效的条目。不能用于视图。 Populate_Geometry_Columns：比上一个更复杂一点。它通过检查视图和缺少几何约束的表来添加geometry_columns的元数据。如果不带任何参数调用这个，会把geometry_columns表中的内容全部删除，然后重新填充，消耗时间会很长。 到目前为止我们是通过AddGeometryColumn来添加几何列的。尽管不使用它也能添加几何列，但是在PostGIS2.0版本以前，强烈推荐使用这个。因为它不仅会添加几何列，还会自动维护geometry_columns表。如果使用pgsql原生的方法来添加几何列，需要的操作很多，如果忘了一步就会产生麻烦。 2、几何类型全览本节会详细介绍PostGIS中的所有几何类型。 1、什么是几何在本书中，使用几何来表示GIS中使用的泛化的几何形状和PostGIS中的几何数据类型。PostGIS的几何数据类型遵从OpenGIS标准的几何定义。下面以几个例子看一下：首先创建一个表来存储将展示的所有几何对象： 1234CREATE TABLE my_geometries ( id SERIAL NOT NULL PRIMARY KEY, name varchar(20)); 这里没有指定schema，则直接放在public schema中。pgsql的schema搜索默认是从public开始的。 2、点PostGIS中所有的几何类型都是基于笛卡尔坐标系的。例如：2D(X,Y),3D(X,Y,Z),2DM(X,Y,M),3DM(X,Y,Z,M)。M坐标是一个附加的双精度数值型值。它可以存储到几何对象的任何点中。可正可负，并且它的单位不需要和所在的空间参考系有任何关系。目前就有两种类型2DM,3DM。接下来在之前创建的表中添加一个点几何类型列，并且插入几个点： 1234567SELECT AddGeometryColumn(&apos;public&apos;, &apos;my_geometries&apos;, &apos;my_points&apos;, -1, &apos;POINT&apos;, 2);INSERT INTO my_geometries (name,my_points)VALUES (&apos;Home&apos;,ST_GeomFromText(&apos;POINT(0 0)&apos;));INSERT INTO my_geometries (name,my_points)VALUES (&apos;Pizza 1&apos;,ST_GeomFromText(&apos;POINT(1 1)&apos;)) ;INSERT INTO my_geometries (name,my_points)VALUES (&apos;Pizza 2&apos;,ST_GeomFromText(&apos;POINT(1 -1)&apos;)); 添加了三个点到表中。 3、线串线串至少有两个不同的点来定义。线串根据包含的点的维度不同也有四种不同的变形。接下来在表中添加线串的列： 1234567SELECT AddGeometryColumn(&apos;public&apos;, &apos;my_geometries&apos;, &apos;my_linestrings&apos;, -1, &apos;LINESTRING&apos;, 2);INSERT INTO my_geometries (name,my_linestrings)VALUES (&apos;Linestring Open&apos;,ST_GeomFromText(&apos;LINESTRING(0 0,1 1,1 -1)&apos;));INSERT INTO my_geometries (name,my_linestrings)VALUES (&apos;Linestring Closed&apos;,ST_GeomFromText(&apos;LINESTRING(0 0,1 1,1 -1, 0 0)&apos;)); 添加了两条线串到表中，一条开放的，一条闭合的。闭合线串是创建多边形的基础。当描述线串时会有简单和非简单几何对象的概念。除了起止点外，如果线串自身没有相交，那就是简单的，否则是非简单的。ST_IsSimple函数可以来判断是否是简单的。 1SELECT ST_IsSimple(ST_GeomFromText(&apos;LINESTRING(2 0,0 0,1 1,1 -1)&apos;)); 4、多边形多边形是通过我们之前熟悉的其他几何类型组成的。接下来我们创建一个如下图的三角形： 这个三角形由一条闭合的线串+由该线串包围的所有点构成。线串叫做这个多边形的外环。 123SELECT AddGeometryColumn(&apos;public&apos;,&apos;my_geometries&apos;, &apos;my_polygons&apos;,-1,&apos;POLYGON&apos;,2);INSERT INTO my_geometries (name,my_polygons)VALUES (&apos;Triangle&apos;, ST_GeomFromText(&apos;POLYGON((0 0, 1 1, 1 -1, 0 0))&apos;)); 很多情况下，多边形只有一个环，但是多边形是可以有多个来组成的。每个外环可以有0个或多个内环，这些内环构成了多边形的“洞”。接下来创建一个带两个洞的多边形： 其中阴影部分是多边形，空白部分是多边形的洞。 12345INSERT INTO my_geometries (name,my_polygons)VALUES (&apos;Square with 2 holes&apos;, ST_GeomFromText(&apos;POLYGON( (-0.25 -1.25,-0.25 1.25,2.5 1.25,2.5 -1.25,-0.25 -1.25), (2.25 0,1.25 1,1.25 -1,2.25 0),(1 -1,1 1,0 0,1 -1))&apos;)); 因此多边形的文本表示形式中会有多一对小括号。即使你的多边形只有一个环也要加上。对于多边形来说，存在有效性的概念。有效多边形的环应该不相交或者只在不同的点上有相交。 5、容器几何类型这个名字还有待商榷，英文是Collection geometries。想象这么一种情况，假设要把美国的每个州都用几何对象表示出来。那么处理夏威夷的时候就有问题了，因为它是由5个分开的块组成的。如果我们把这一个州用5个多边形来表示，那么存储格式就会很麻烦了。为了解决这个问题，OGC标准和PostGIS都提供了容器几何类型。它将多个分开的几何对象在逻辑上组合起来。对于每一种单独的几何数据类型，都有一个容器类型： point-&gt;multipoints linestring-&gt;multilinestrings polygon-&gt;multipolygons 除了这些还存在一个geometrycollection类型，可以存储任何的几何类型，前提是它们有相同的空间参考系和空间维度。 1）multipoints这个就只是存储多个点的容器而已。使用WKT语法表示multipoints有以下几种类型： 2D：MULTIPOINT(-1 1, 0 0, 2 3) 2DM：MULTIPOINTM(-1 1 4, 0 0 2, 2 3 2) 3D：MULTIPOINT(-1 1 3, 0 0 1, 2 3 1) 3DM：MULTIPOINT(-1 1 3 4, 0 0 1 2, 2 3 1 2) 注意2DM那种是有区别的。另外还有一种格式，以2D为例：MULTIPOINT((-1 1), (0 0), (2 3))。和上面的格式对比，只是对于每一个点都加了一对小括号。以上两种格式在PostGIS中都可以作为输入格式。但是以文本输出格式是不带小括号那种。 2）multilinestrings这个就是存储线串的容器。有以下几种格式： 2D：MULTILINESTRING((0 0,0 1,1 1),(-1 1,-1 -1)) 2DM：MULTILINESTRINGM((0 0 1,0 1 2,1 1 3),(-1 1 1,-1 -1 2)) 3D：MULTILINESTRING((0 0 1,0 1 2,1 1 3),(-1 1 1,-1 -1 2)) 3DM：MULTILINESTRING((0 0 1 1,0 1 1 2,1 1 1 3),(-1 1 1 1,-1 -1 1 2)) 注意这里的小括号是不能省略的，要不就成了点容器了。 对比之前所说过的线串的简单性，multilinestrings也有简单性的概念： 容器中的每个线串都必须是简单的。 容器中的每两个线串之间不相交。 否则就是非简单的。 3）multipolygons在多边形容器的文本表示法中，会有很多的小括号。每对小括号都表示多边形的一个环。然后再有一对小括号表示一个多边形。再有一对小括号表示multipolygons。下面照样是几种表示格式： 2D：MULTIPOLYGON(((2.25 0,1.25 1,1.25 -1,2.25 0)), ((1 -1,1 1,0 0,1 -1))) 2DM：MULTIPOLYGONM(((2.25 0 1,1.25 1 2,1.25 -1 1,2.25 0 1)), ((1 -1 1,1 1 2,0 0 3,1 -1 4)) ) 3D：MULTIPOLYGON(((2.25 0 1,1.25 1 1,1.25 -1 1,2.25 0 1)), ((1 -1 2,1 1 2,0 0 2,1 -1 2)) ) 3DM：MULTIPOLYGON(((2.25 0 1 1,1.25 1 1 2,1.25 -1 1 1,2.25 0 1 1)), ((1 -1 2 1,1 1 2 2,0 0 2 3,1 -1 2 4)) 对比之前所说的多边形的有效性，multipolygons也有有效性的概念： 容器中的每个多边形都必须是有效的。 容器中的每两个多边形不能互相覆盖。在第四章会详细的说覆盖的概念。 4）geometrycollectiongeometrycollection可以包含PostGIS中任何已知的几何类型，目前这里的任何表示单独的几何类型+它们对应的容器几何类型+geometrycollection。并且包含的几何类型不需要是相同的。对于存储来说，这种可以包含任意类型的容器是很棒的。但是对于很多PostGIS的函数来说对这种容器是没有意义的。例如你可以计算多个多边形的面积，但是你不能计算一个线串和一个多边形的面积吧。 geometrycollection起源于作为查询的返回结果，而不是表中预定义好的列。要尽量避免在表设计时使用这个，但是在处理数据时要考虑到它的存在。 下面给出一些例子： 1234567891011121314SELECT ST_AsText(ST_Collect(the_geom))FROM ( SELECT ST_GeomFromText(&apos;MULTIPOINT(-1 1, 0 0, 2 3)&apos;) As the_geom UNION ALL SELECT ST_GeomFromText(&apos;MULTILINESTRING((0 0,0 1,1 1), (-1 1,-1 -1))&apos;) As the_geom UNION ALL SELECT ST_GeomFromText( &apos;POLYGON( (-0.25 -1.25,-0.25 1.25, 2.5 1.25,2.5 -1.25,-0.25 -1.25), (2.25 0,1.25 1,1.25 -1,2.25 0), (1 -1,1 1,0 0,1 -1) )&apos; ) As the_geom) As foo; 以上SQL代码创建了一个geometrycollection，下面是它的输出结果： 12345GEOMETRYCOLLECTION( MULTIPOINT(-1 1,0 0,2 3), MULTILINESTRING((0 0,0 1,1 1),(-1 1,-1 -1)), POLYGON((-0.25 -1.25,-0.25 1.25,2.5 1.25,2.5 -1.25,-0.25 -1.25),(2.25 0,1.25 1,1.25 -1,2.25 0),(1 -1,1 1,0 0,1 -1))) 下面是另外一个例子： 1234567891011121314SELECT ST_AsEWKT(ST_Collect(the_geom)) FROM ( SELECT ST_GeomFromEWKT(&apos;MULTIPOINTM(-1 1 4, 0 0 2, 2 3 2)&apos;) As the_geom UNION ALL SELECT ST_GeomFromEWKT(&apos;MULTILINESTRINGM((0 0 1,0 1 2,1 1 3), (-1 1 1,-1 -1 2))&apos;) As the_geom UNION ALL SELECT ST_GeomFromEWKT( &apos;POLYGONM( (-0.25 -1.25 1,-0.25 1.25 2, 2.5 1.25 3,2.5 -1.25 1,-0.25 -1.25 1), (2.25 0 2,1.25 1 1,1.25 -1 1,2.25 0 2), (1 -1 2,1 1 2,0 0 2,1 -1 2) )&apos; ) As the_geom) As foo; 输出结果为： 12345678GEOMETRYCOLLECTIONM( MULTIPOINTM(-1 1 4,0 0 2,2 3 2), MULTILINESTRINGM((0 0 1,0 1 2,1 1 3),(-1 1 1,-1 -1 2)), POLYGONM( (-0.25 -1.25 1,-0.25 1.25 2,2.5 1.25 3,2.5 -1.25 1,-0.25 -1.25 1), (2.25 0 2,1.25 1 1,1.25 -1 1,2.25 0 2),(1 -1 2,1 1 2,0 0 2,1 -1 2) )) 在第一个例子中是2D的，对应使用ST_AsText和ST_GeomFromText来做序列化和反序列化。在第二个例子中是2DM的，对应使用ST_AsEWKT和ST_GeomFromEWKT来做序列化和反序列化。 这是因为在兼容OGC标准的函数中，ST_AsText和ST_GeomFromText只是被设计为用于2D的。ST_AsEWKT和ST_GeomFromEWKT是PostGIS创建的，可以应用于任何维度的。其中E表示扩展的。使用这种扩展的函数还有另外一个好处是它还会返回它已经的空间参考系的标识符。 geometrycollection的有效性只有一条规则： 容器中的每个元素都是有效的。 不满足这个规则则不是有效的。 6、曲线几何在PostGIS1.3开始，提供了基本的曲线几何的支持。曲线几何是在OGC SQL-MM Part 3规范中引入的。在PostGIS中曲线几何还远不如其他几何类型成熟，并且也没有被广泛支持。自然的陆地特征很少表现为曲线几何，人造的结构和边界确实会有曲线，但是在许多建模例子中，都可以被约等于为直线。在很多情况下，尽管实际情况是曲线，但是使用线串更加合适。因为处理速度往往比精度更重要。 使用曲线几何的一些注意事项： 很少的第三方工具支持曲线几何，无论是开源还是商业的。 PostGIS中许多函数使用的高级空间库GEOS不支持曲线几何。一个应变方法是使用ST_CurveToLine和ST_LineToCurve来做曲线和线串的相互转换，但是这样会丢失一下处理效率和精度。 许多PostGIS函数不支持曲线几何。 曲线几何不被PostGIS支持，所以使用它很可能是有BUG的。不过在后期的版本中很可能会修复许多BUG，并且扩展许多函数。 既然曲线几何有这么多缺点，那么为什么还要使用它呢？有以下几种原因： 可以使用很少的几个点来表示一个曲线几何对象。 许多工具将会引进曲线几何。 PostGIS正在增加对曲线几何的支持。 曲线几何在一些情况下很重要，例如对人造结构进行建模时。 尽管不用曲线几何存储数据，但是使用曲线几何WKT格式作为中间媒介画一个四分之一圆是很有用的，然后可以使用ST_CurveToLine函数来转换成多边形。 简单来说，你可以认为在PostGIS中，曲线几何就是带弧的几何类型。为了创建一个弧，必须有三个不同的点：起点、终点、控制点。控制点用于控制弧的曲率。如下图所示： 1）CIRCULARSTRING由多条弧首尾相连构成了另外一种曲线几何类型circularstring（圆环串），上图就是一个很好的例子。circularstring是所有曲线几何类型中最简单的，仅仅只包含了弧。 下面给出一个创建circularstring的例子： 12345678SELECT AddGeometryColumn (&apos;public&apos;,&apos;my_geometries&apos;, &apos;my_circular_strings&apos;,-1,&apos;CIRCULARSTRING&apos;,2);INSERT INTO my_geometries(name, my_circular_strings)VALUES (&apos;Circle&apos;, ST_GeomFromText(&apos;CIRCULARSTRING(0 0,2 0, 2 2, 0 2, 0 0)&apos;)), (&apos;Half Circle&apos;, ST_GeomFromText(&apos;CIRCULARSTRING(2.5 2.5,4.5 2.5, 4.5 4.5)&apos;)), (&apos;Several Arcs&apos;, ST_GeomFromText(&apos;CIRCULARSTRING(5 5,6 6,4 8, 7 9, 9.5 9.5, 11 12, 12 12)&apos;)); 上面创建的曲线几何对象如下图所示： 下面的代码计算出已曲线表示和已线串表示需要的点的个数： 123456SELECT name, ST_NPoints(my_circular_strings) As cnpoints, ST_NPoints(ST_CurveToLine(my_circular_strings)) As lnpointsFROM my_geometriesWHERE my_circular_strings IS NOT NULL; 结果如下： 2）COMPOUNDCURVES由圆环串（circularstring）和线串以一定序列构成的几何容器，叫做复合曲线。由复合曲线构成的多边形叫做曲线多边形，例如圆角矩形。 下面是一个创建复合曲线的例子： 12345SELECT AddGeometryColumn (&apos;public&apos;,&apos;my_geometries&apos;,&apos;my_compound_curves&apos;, -1,&apos;COMPOUNDCURVE&apos;,2);INSERT INTO my_geometries(name,my_compound_curves)VALUES ( &apos;Road with curve&apos;, ST_GeomFromText(&apos;COMPOUNDCURVE((2 2, 2.5 2.5), CIRCULARSTRING(2.5 2.5,4.5 2.5, 3.5 3.5), (3.5 3.5, 2.5 4.5, 3 5))&apos;)); 创建的复合曲线如下： 3）CURVEPOLYGON曲线多边形是一个使用圆环串作为外环或者内环的多边形。下面是一个创建曲线多边形的例子： 123456789SELECT AddGeometryColumn (&apos;public&apos;,&apos;my_geometries&apos;, &apos;my_curve_polygons&apos;,-1,&apos;CURVEPOLYGON&apos;,2);INSERT INTO my_geometries(name,my_curve_polygons)VALUES (&apos;Solid Circle&apos;, ST_GeomFromText(&apos;CURVEPOLYGON( CIRCULARSTRING(0 0,2 0, 2 2, 0 2, 0 0))&apos;)), (&apos;Circle t hole&apos;, ST_GeomFromText(&apos;CURVEPOLYGON(CIRCULARSTRING(2.5 2.5,4.5 2.5, 4.5 3.5, 2.5 4.5, 2.5 2.5), (3.5 3.5, 3.25 2.25, 4.25 3.25, 3.5 3.5) )&apos;) ), (&apos;T arcish hole&apos;, ST_GeomFromText(&apos;CURVEPOLYGON((-0.5 7, -1 5, 3.5 5.25, -0.5 7), CIRCULARSTRING(0.25 5.5, -0.25 6.5, -0.5 5.75, 0 5.75, 0.25 5.5))&apos;)); 创建的曲线多边形如下： 7、3D几何类型PostGIS可以识别和存储3D几何对象，但是对它的支持还是有很多缺陷的。在之前的例子中我们看到，可以很容易的创建3D的点、线串、多边形等。但是要明白它们是缺乏体积的感知的。它们只是把2D中的点放到了3D空间而已，或者叫做2.5D。 使用3D几何类型的一些注意事项： PostGIS和底层的GEOS库对3D几何类型有很少的支持。例如所有的关系操作符仅仅只是检查相应的2D维度，而完全忽略Z坐标。 上层函数例如求交、求并仅仅部分处理第三维。 空间操作实现的很棒的速度，通过使用边界框索引。不幸的是现在边界框索引还不支持第三维。 3、总结本章所讲的内容： geometry_columns元表 5个和geometry_columns元表交互的函数 点、线串、多边形 点容器、线串容器、多边形容器、几何类型容器 曲线几何和3D几何 在建模的时候不要想太严格的定义。例如，如果看起来、感觉是多边形，那么就把它当做多边形。不要对内环，外环过分担心除非你特别需要。","link":"/2020/05/16/postgis-in-action-ch2/"},{"title":"PostGIS源码-0-开篇","text":"从这篇文章开始，学习PostGIS的源码。有了之前编写PostgreSQL扩展插件那篇文章后，已经了解PostgreSQL插件开发的基本流程了，这对于学习PostGIS的源码核心部分来说已经够用了。 PostGIS源码版本：3.0.1 PostgreSQL版本：10.12 一、基本介绍先看下PostGIS的目录结构： ./ 根目录下的文件基本上都是和配置相关的一些脚本和安装文件 ./deps 额外的依赖项 ./doc 文档目录（我在看源码时，把这个目录删掉了，因为使用全局搜索时这个目录会有很大干扰。而且想要看文档的话，去官网看还更好看一些） ./extensions 用于支持PostgreSQL扩展插件的框架 ./extras 非核心的一些东西，目前不关注这个 ./liblwgeom LWGEOM几何库 ./libpgcommon LWGEOM和PostgreSQL之间的桥梁 ./loader 用于载入PostGIS数据的一些程序 ./postgis PostGIS提供的函数接口的主要代码 ./raster 光栅扩展 ./regress PostgreSQL的回归测试相关内容 ./topology 拓扑扩展相关 ./utils 一些工具脚本，例如升级相关的工具 剩下的目录或者文件基本上就是和配置、构建、安装相关的了，现在不关心那些。后续可以再写一篇文章，来看看autoconf等工具的使用方法。 目前主要学习./liblwgeom、./libpgcommon、./postgis及其涉及到的部分代码。 PostGIS只是PostgreSQL的一个扩展插件，并不是一个完整的独立的程序，它提供的只是一系列的函数、类型和其相关的操作符重载。因此我没想到什么好的学习方法，只能把每个目录下的源码文件，分成几个大致相同的类别，然后一个类别一个类别的去看。 二、准备工作现在我们手里有的只是一份PostGIS的源码，但是如何方便高效的去阅读它是一个问题。 首先，阅读代码的工具我使用的是Source Insight 4，因为之前看libevent代码的时候使用的也是这个，觉得还是挺方便的，所以就继续用它了。 其次，PostGIS源码中有很多的.in文件，这个之后会被配置替换成对应的代码文件。如果是在C代码中包含的头文件是.h，而现在源码中的是.h.in的话，是不能直接跳转到对应的头文件中的，而且里面的内容应该也要根据平台来进行修正。所以我把源码丢到centos7服务器上编译了一下，完成再把子目录中的目标文件删除掉。然后把代码搞到本地，作为要阅读的代码。我还把doc目录给删掉了，理由上面提到过了。即执行了以下命令： 123./configuremakefind ./ -name *.o | xargs rm -f 然后，打开Source Insight创建项目，把源码添加到项目中。 另外，PostGIS有用到PostgreSQL库，我把PostgeSQL库的C语言头文件也拷下来了，在Source Insight中添加头文件包含目录（Options-&gt;Preferences-&gt;Symbol Lookups-&gt;Import Symbols in Current project），这样就能方便的跳转到对应的声明处了（但是还是有点问题，如果是#include “sub/file.h”这样的，还是找不到）。 到此为止，准备工作就做完了，后续可以开始看源码了。 注意：后面的文章需要对PostGIS有点了解，例如PostGIS中的一些基本概念、基本数据类型等要知道一点。","link":"/2020/05/30/read-postgis-code-0/"},{"title":"编写PostgreSQL扩展插件","text":"这篇文章来看一下写一个PostgreSQL的扩展插件的流程。以36进制的一系列相关内容为例。 参考： Writing Postgres Extensions - The Basics - Big elephants https://www.postgresql.org/docs/current/xfunc-c.html#DFUNC 在PostgreSQL中使用或者加载插件是在数据库中执行CREATE EXTENSION命令。要执行这个命令，至少需要两个文件： extension_name.control：告诉PostgreSQL关于这个插件的一些基本信息。 extension–version.sql：插件的SQL脚本文件。 一、函数扩展1、实现36进制转换函数首先实现的插件只包含一个36进制转换的函数，来看一下具体的工作流程。先写出上面提到的两个文件： base36.control 1234# base36 extensioncomment = &apos;base36 datatype&apos;default_version = &apos;0.0.1&apos;relocatable = true base36–0.0.1.sql 123456789101112131415161718192021222324-- complain if script is sourced in psql, rather than via CREATE EXTENSION\\echo Use &quot;CREATE EXTENSION base36&quot; to load this file. \\quitCREATE FUNCTION base36_encode(digits int)RETURNS textLANGUAGE plpgsql IMMUTABLE STRICT AS $$ DECLARE chars char[]; ret varchar; val int; BEGIN chars := ARRAY[ &apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;, &apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;l&apos;,&apos;m&apos;,&apos;n&apos;,&apos;o&apos;,&apos;p&apos;,&apos;q&apos;,&apos;r&apos;,&apos;s&apos;,&apos;t&apos;, &apos;u&apos;,&apos;v&apos;,&apos;w&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos; ]; val := digits; ret := &apos;&apos;; WHILE val != 0 LOOP ret := chars[(val%36)+1] || ret; val := val/36; END LOOP; RETURN(ret); END $$; 这里有两个地方注意下。首先是第二行，这行的作用是防止这个文件被直接当做脚本文件来执行。这个文件只能在使用CREATE EXTENSION命令时被执行。其次是LANGUAGE plpgsql，这个我也没见过，查了一下它也是一种程序语言，叫做过程化SQL语言，是PostgrSQL对SQL语句的扩展。 写完这两个文件后，把他们放到PostgreSQL安装目录下的share/extension目录下就完成了。 当插件内容多了之后，我们在手动把编写的文件复制到指定目录下就很不方便了。PostgreSQL在9.1版本之后为插件安装提供了构建程序：PGXS，使得可以方便的组织插件的源代码、源文件。通过编写一个Makefile文件来实现。 Makefile 1234567EXTENSION = base36 # the extensions nameDATA = base36--0.0.1.sql # script files to install# postgres build stuffPG_CONFIG = pg_configPGXS := $(shell $(PG_CONFIG) --pgxs)include $(PGXS) 把上面三个文件放到一个目录（任意）当中，然后执行make install就能自动的把我们的插件添加到PostgreSQL的目录中了。 执行然make install后，使用psql连接上我们的数据库，简单的测试一下： 12345678postgres=# CREATE EXTENSION base36;CREATE EXTENSIONpostgres=# SELECT base36_encode(123456789)postgres-# ; base36_encode --------------- 21i3v9(1 row) 至此，我们的第一个版本的插件就完成了。 2、增加回归测试PostgreSQL提供了回归测试的功能，在make install后执行make installcheck可以自动跑一遍我们指定的测试用例。现在，来看下如何写测试用例。 我们需要提供测试用例的脚本文件和期望的输出结果文件。分别放在插件项目的sql/和expected/子目录下。 测试脚本文件 sql/base36_test.sql 1234567CREATE EXTENSION base36;SELECT base36_encode(0);SELECT base36_encode(1);SELECT base36_encode(10);SELECT base36_encode(35);SELECT base36_encode(36);SELECT base36_encode(123456789); 然后我们还需要修改Makefile文件，来告诉make命令我们增加了测试用例： Makefile 1234567EXTENSION = base36DATA = base36--0.0.1.sqlREGRESS = base36_testPG_CONFIG = pg_configPGXS := $(shell $(PG_CONFIG) --pgxs)include $(PGXS) 然后执行make install &amp;&amp; make installcheck命令，会输出results/base36_test.out文件，然后在拿这个文件去和expected/base36_test.out文件比对的时候，发现后者不存在，那么我们增加期望输出文件，里面的内容就使用刚才results中输出的内容。 123456789101112131415161718192021222324252627282930313233343536CREATE EXTENSION base36;SELECT base36_encode(0); base36_encode ---------------(1 row)SELECT base36_encode(1); base36_encode --------------- 1(1 row)SELECT base36_encode(10); base36_encode --------------- a(1 row)SELECT base36_encode(35); base36_encode --------------- z(1 row)SELECT base36_encode(36); base36_encode --------------- 10(1 row)SELECT base36_encode(123456789); base36_encode --------------- 21i3v9(1 row) 再次执行make installcheck就会输出： 1234567891011============== dropping database &quot;contrib_regression&quot; ==============DROP DATABASE============== creating database &quot;contrib_regression&quot; ==============CREATE DATABASEALTER DATABASE============== running regression test queries ==============test base36_test ... ok===================== All 1 tests passed. ===================== 注意：这里的回归测试使用的是PostgreSQL的pg_regress程序，使用我们的Makefile文件的话，会去连接PostgreSQL的默认端口5432。如果使用了自定义的端口的话，我不知道怎么增加参数来指定pg_regress连接的端口。只能临时的在Makefile文件中把指定回归测试那一行，取巧的增加了端口参数： 1REGRESS = --port=4096 base36_test 这样操作能行的原因是，我看原来的写法中base36_test这个字符串是放到pg_regress命令的最后一个参数位置。 更：后来在某个地方看到了增加参数的写法，只要再REGRESS前加上一行下面的代码即可： 1REGRESS_OPTS = --port=4096 这个版本的代码中有个bug，0的进制转换并没有输出，这个确实是代码里有问题，修改base36–0.0.1.sql，增加下面的特判： 123IF digits = 0 THEN RETURN (&apos;0&apos;);END IF; 然后修改expected目录下的.out文件中的结果。 3、使用C语言来实现之前使用的是plpgsql来实现的函数，效率比较低。举个例子，我们执行100万次这个函数： 1SELECT i,base36_encode(i) FROM generate_series(1, 1e6::int) i; 在我的服务器上，执行完上面这条命令大约需要7秒的时间。 下面我们来看看如何使用C语言来实现功能，以及它的效率如何。 先写好C语言的代码： base36.c 1234567891011121314151617181920212223#include &quot;postgres.h&quot;#include &quot;fmgr.h&quot;#include &quot;utils/builtins.h&quot;PG_MODULE_MAGIC;PG_FUNCTION_INFO_V1(base36_encode);Datumbase36_encode(PG_FUNCTION_ARGS){ int32 arg = PG_GETARG_INT32(0); char base36[37] = &quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;; char * buffer = palloc(7* sizeof(char)); unsigned int offset = 7; buffer[--offset] = 0; do{ buffer[--offset] = base36[arg % 36]; }while (arg/=36); PG_RETURN_TEXT_P(cstring_to_text(&amp;buffer[offset]));} 首先是三个头文件，它们在PostgreSQL安装目录/include/server/下。 postgres.h：包含了PostgreSQL的许多基础内容。 fmgr.h：提供了PG_GETARG_XX和PG_RETURN_XXX这样的宏。 utils/builtins.h：提供了许多操作PostgreSQL内置数据类型的函数。 然后PG_MODULE_MAGIC是为了提供兼容性的。 PG_FUNCTION_INFO_V1(base36_encode);指定函数的调用约定为Version 1。还有一个调用约定是Version 0。 Datum是PostgreSQL提供的一种C语言数据类型，类似void *。 PG_FUNCTION_ARGS类似C语言的可变参数，可以接受任意个数的参数，通过PG_GETARG_XX宏来获取第几个参数。 palloc是PostgreSQL提供的C语言内存申请函数。在PostgreSQL插件编写中，只使用palloc和pfree，不要使用C语言的malloc和free。并且palloc申请的内存会被自动释放。还有一个申请内存的函数是palloc0，这个会初始化内存为0。 最后一句PG_RETURN_TEXT_P(cstring_to_text(&amp;buffer[offset]));，使用PG_RETURN_XX宏来返回内容给PostgreSQL，cstring_to_text函数用于把C字符串转换成PostgreSQL的text数据类型。 C语言代码写完了，接下来要把它编译链接成.so（动态库）文件。因为代码里用到了PostgreSQL的头文件，所以需要把头文件的搜索目录添加到系统的C头文件搜索目录中： 1export C_INCLUDE_PATH=$C_INCLUDE_PATH:/PostgreSQL_Path/include/server/ 然后使用gcc进行编译链接： 12gcc -fPIC -c base36.cgcc -shared -o base36.so base36.o 接下来要修改之前的文件，来使用刚刚写好的C语言代码生成的动态库。 更：后来发现，不用自己手动去执行编译和链接，Makefile也不用修改，直接执行make &amp;&amp; make install就可以。 base36–0.0.1.sql 12345-- complain if script is sourced in psql, rather than via CREATE EXTENSION\\echo Use &quot;CREATE EXTENSION base36&quot; to load this file. \\quitCREATE FUNCTION base36_encode(digits int) RETURNS textAS &apos;$libdir/base36&apos;LANGUAGE C IMMUTABLE STRICT; 通过执行pg_config --pkglibdir可以查看$libdir是什么。 Makefile 123456789EXTENSION = base36DATA = base36--0.0.1.sqlREGRESS = base36_test#new lineMODULES = base36 PG_CONFIG = pg_configPGXS := $(shell $(PG_CONFIG) --pgxs)include $(PGXS) 然后执行make install &amp;&amp; make installcheck安装插件，再psql连接到数据库，重新创建base36扩展插件。 现在再执行之前的调用100万次函数的SQL语句，大约需要1秒多的时间。 接下来完善一下我们base36_encode函数的代码，增加上对负数的错误处理。在C代码中增加如下内容： 12345678if(arg &lt; 0){ ereport(ERROR,( errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE), errmsg(&quot;negative values are not allowed&quot;), errdetail(&quot;value %d is negative&quot;, arg), errhint(&quot;make it positive&quot;) )); } 然后重新安装和创建插件，测试如下： 1234postgres=# SELECT base36_encode(-10);ERROR: negative values are not allowedDETAIL: value -10 is negativeHINT: make it positive 以上，就完成了一个简单的插件编写了。如果想了解更详细的内容，去查官方的文档：PostgreSQL扩展 二、类型扩展上面一节实现了将十进制数字转换成36进制的函数，接下来看一下如何将base36作为一种数据类型加入到PostgreSQL中。 首先，修改base36–0.0.1.sql文件 123456789101112131415161718-- complain if script is sourced in psql, rather than via CREATE EXTENSION\\echo Use &quot;CREATE EXTENSION base36&quot; to load this file. \\quitCREATE FUNCTION base36_in(cstring)RETURNS base36AS &apos;$libdir/base36&apos;LANGUAGE C IMMUTABLE STRICT;CREATE FUNCTION base36_out(base36)RETURNS cstringAS &apos;$libdir/base36&apos;LANGUAGE C IMMUTABLE STRICT;CREATE TYPE base36( INPUT = base36_in, OUTPUT = base36_out, LIKE = integer); 上面的代码，就是添加新的数据类型所需的最少内容了。 在类型定义中，INPUT和OUTPUT指定了两个函数，这两个函数是用于将36进制文本转换为36进制类型或者反向转换。 LIKE表示让PostgreSQL把base36像整数那样对待。 下面修改C代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &quot;postgres.h&quot;#include &quot;fmgr.h&quot;#include &quot;utils/builtins.h&quot;#include &lt;stdlib.h&gt;PG_MODULE_MAGIC;PG_FUNCTION_INFO_V1(base36_in);Datumbase36_in(PG_FUNCTION_ARGS){ long result; char* str = PG_GETARG_CSTRING(0); result = strtol(str, NULL, 36); PG_RETURN_INT32((int32)result);}PG_FUNCTION_INFO_V1(base36_out);Datumbase36_out(PG_FUNCTION_ARGS){ int32 arg = PG_GETARG_INT32(0); if(arg &lt; 0){ ereport(ERROR,( errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE), errmsg(&quot;negative values are not allowed&quot;), errdetail(&quot;value %d is negative&quot;, arg), errhint(&quot;make it positive&quot;) )); } char base36[37] = &quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;; char * buffer = palloc(7* sizeof(char)); unsigned int offset = 7; buffer[--offset] = 0; do{ buffer[--offset] = base36[arg % 36]; }while (arg/=36); PG_RETURN_CSTRING(&amp;buffer[offset]);} 从代码上可以看到，其实只是把36进制转换成了int32来存储。 写完代码后执行make &amp;&amp; make install，然后测试： 123456789101112test=# CREATE TABLE base36_test(val base36);CREATE TABLEtest=# INSERT INTO base36_test VALUES (&apos;123&apos;), (&apos;3c&apos;), (&apos;5A&apos;), (&apos;zZz&apos;);INSERT 0 4test=# SELECT * FROM base36_test; val----- 123 3c 5a zzz(4 rows) 这样就完成添加新的数据类型。 三、操作符扩展在完成上面的测试后，我们执行下面的SQL语句，将查询到的内容排序输出： 12345postgres=# select * from base36_test order by val;ERROR: could not identify an ordering operator for type base36LINE 1: select * from base36_test order by val; ^HINT: Use an explicit ordering operator or modify the query. 执行出错，提示没有对应的比较操作符。确实应该如此，对于一个新的数据类型，如果我们不给出操作符重载，那么PostgreSQL怎么能知道该如何去比较大小呢。 在base36–0.0.1.sql文件中增加如下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899CREATE FUNCTION base36_eq(base36, base36)RETURNS boolean LANGUAGE internal IMMUTABLE AS &apos;int4eq&apos;;CREATE FUNCTION base36_ne(base36, base36)RETURNS boolean LANGUAGE internal IMMUTABLE AS &apos;int4ne&apos;;CREATE FUNCTION base36_lt(base36, base36)RETURNS boolean LANGUAGE internal IMMUTABLE AS &apos;int4lt&apos;;CREATE FUNCTION base36_le(base36, base36)RETURNS boolean LANGUAGE internal IMMUTABLE AS &apos;int4le&apos;;CREATE FUNCTION base36_gt(base36, base36)RETURNS boolean LANGUAGE internal IMMUTABLE AS &apos;int4gt&apos;;CREATE FUNCTION base36_ge(base36, base36)RETURNS boolean LANGUAGE internal IMMUTABLE AS &apos;int4ge&apos;;CREATE FUNCTION base36_cmp(base36, base36)RETURNS integer LANGUAGE internal IMMUTABLE AS &apos;btint4cmp&apos;;CREATE FUNCTION hash_base36(base36)RETURNS integer LANGUAGE internal IMMUTABLE AS &apos;hashint4&apos;;CREATE OPERATOR = ( LEFTARG = base36, RIGHTARG = base36, PROCEDURE = base36_eq, COMMUTATOR = &apos;=&apos;, NEGATOR = &apos;&lt;&gt;&apos;, RESTRICT = eqsel, JOIN = eqjoinsel, HASHES, MERGES);CREATE OPERATOR &lt;&gt; ( LEFTARG = base36, RIGHTARG = base36, PROCEDURE = base36_ne, COMMUTATOR = &apos;&lt;&gt;&apos;, NEGATOR = &apos;=&apos;, RESTRICT = neqsel, JOIN = neqjoinsel);CREATE OPERATOR &lt; ( LEFTARG = base36, RIGHTARG = base36, PROCEDURE = base36_lt, COMMUTATOR = &gt; , NEGATOR = &gt;= , RESTRICT = scalarltsel, JOIN = scalarltjoinsel);CREATE OPERATOR &lt;= ( LEFTARG = base36, RIGHTARG = base36, PROCEDURE = base36_le, COMMUTATOR = &gt;= , NEGATOR = &gt; , RESTRICT = scalarltsel, JOIN = scalarltjoinsel);CREATE OPERATOR &gt; ( LEFTARG = base36, RIGHTARG = base36, PROCEDURE = base36_gt, COMMUTATOR = &lt; , NEGATOR = &lt;= , RESTRICT = scalargtsel, JOIN = scalargtjoinsel);CREATE OPERATOR &gt;= ( LEFTARG = base36, RIGHTARG = base36, PROCEDURE = base36_ge, COMMUTATOR = &lt;= , NEGATOR = &lt; , RESTRICT = scalargtsel, JOIN = scalargtjoinsel);CREATE OPERATOR CLASS btree_base36_opsDEFAULT FOR TYPE base36 USING btreeAS OPERATOR 1 &lt; , OPERATOR 2 &lt;= , OPERATOR 3 = , OPERATOR 4 &gt;= , OPERATOR 5 &gt; , FUNCTION 1 base36_cmp(base36, base36);CREATE OPERATOR CLASS hash_base36_ops DEFAULT FOR TYPE base36 USING hash AS OPERATOR 1 = , FUNCTION 1 hash_base36(base36); 首先，我们创建了一系列的用于base36的比较函数和操作符。然后把他们放到一个类中，这样就能够在新的数据类型上创建索引了。 另外，我们注意到创建的比较函数使用的都是内置的int的比较函数。 重新安装好后进行测试： 12345postgres=# SELECT &apos;123&apos;::base36 &lt; &apos;23&apos;::base36; ?column? ---------- f(1 row) 接下来看下上面代码中的一些东西： COMMUTATOR ：换向，例如&gt;对应&lt;，&lt;=对应&gt;=。 NEGATOR：否定词，例如&gt;对应&lt;=，&lt;对应&gt;=。 注意：之前的C代码是有bug的，在某些情况下会崩溃。不过这都不重要了，重要的是学习扩展插件的开发过程。","link":"/2020/05/29/write-psql-extension/"},{"title":"PostGIS源码-1-LWGEOM库之基本类型及其序列化","text":"这是PostGIS源码学习正式开始的第一篇，我大致浏览了源码后，发现lwgeom库算是PostGIS的地基。这个库是PostGIS的通用的几何处理部分，包含几何类型、构造/析构（请允许我在C语言中用这两个名词）以及一系列空间处理函数。所以先从这一部分开始。这部分我打算分三篇来写，第一篇看所有的数据类型，以及如何进行GSERIALIZED序列化和反序列化。第二篇在剩下的内容中，挑一些感兴趣的看记录下来。有很多逻辑简单，一看函数名字就知道作用的，就不写了，意义不大。 关于lwgeom这个名字中的lw，它的意义是什么这个问题困扰了我很久。后来通过在查其他东西的时候和看源码的过程中，我大概猜测了一下它的意思：Light-Weight，轻量级的。 lwgeom库在源码目录下的liblwgeom目录下。使用这个库的大部分文件中，只需要包含liblwgeom.h这个头文件就行了。这个头文件中包含了该库导出的绝大部分数据类型和相关函数。光这个头文件就有2400多行。所以我们从这个头文件出发，看到感兴趣的一些声明就跳到具体的实现文件中去学习。下面就开始进入源码了。 首先在这个头文件中，开始先是一系列的宏定义：lwgeom库版本号、真/假、成功/失败、几何类型代号、标志位掩码及其设置/读取宏、SRID的最大范围等。这些从宏的名字可读性比较高，看到时通过宏名字就能识别出它的意义。所以这部分就不贴代码了，免得浪费篇幅。 类似其他开源库，lwgeom也提供给用户设置内存管理函数和日志/调试输出的接口： 123456789101112131415//定义一相关的系列函数指针typedef void* (*lwallocator)(size_t size);typedef void* (*lwreallocator)(void *mem, size_t size);typedef void (*lwfreeor)(void* mem);typedef void (*lwreporter)(const char* fmt, va_list ap) __attribute__ (( format(printf, 1, 0) ));typedef void (*lwdebuglogger)(int level, const char* fmt, va_list ap) __attribute__ (( format(printf, 2,0) ));//提供设置内存管理函数的接口extern void lwgeom_set_handlers(lwallocator allocator, lwreallocator reallocator, lwfreeor freeor, lwreporter errorreporter, lwreporter noticereporter);//提供设置输出调试日志的接口extern void lwgeom_set_debuglogger(lwdebuglogger debuglogger); 上面只是给出了函数指针，具体的函数变量是在lwutil.c中定义的： 1234567//默认的内存管理函数，其实只是对C语言的malloc、realloc、free的调用lwallocator lwalloc_var = default_allocator;lwreallocator lwrealloc_var = default_reallocator;lwfreeor lwfree_var = default_freeor;//默认的日志输出只是通过fprintf输出到stderrlwreporter lwnotice_var = default_noticereporter;lwreporter lwerror_var = default_errorreporter; 一、几何类型这一节，先把所有的几何类型的定义列出来，每个几何类型也就是一个结构体。 1、边界框在PostGIS中为了方便创建几何对象的索引，有一个边界框的概念，就是每个几何对象的每个维度坐标的最大值和最小值。这里存在两个类型BOX3D和GBOX，不同的地方是前者只有3个维度并且有存SRID。后者有4个维度和一个标志位变量，这个标志位使用位掩码来存储很多信息，具体先不讲。我在后面的代码中好像有看到BOX3D是已经不推荐使用了。 12345678910111213141516171819typedef struct{ double xmin, ymin, zmin; double xmax, ymax, zmax; int32_t srid;}BOX3D;typedef struct{ lwflags_t flags; double xmin; double xmax; double ymin; double ymax; double zmin; double zmax; double mmin; double mmax;} GBOX; 关于m维，后面再说。 2、点类型点，也可以说是PostGIS中的坐标，每个几何类型，都要由一个个的点来表示出来。根据维度的不同，目前点有四种类型： 123456789101112131415161718192021222324typedef struct{ double x, y;}POINT2D;typedef struct{ double x, y, z;}POINT3DZ;typedef struct{ double x, y, z;}POINT3D;typedef struct{ double x, y, m;}POINT3DM;typedef struct{ double x, y, z, m;}POINT4D; 2D、3D都好说。关于4D，第4维度是m，表示meaure，度量。用于存储一些时间之类的信息。 所以在PostGIS中最多只有3维的几何体，第4维是额外的一些度量信息。 3、点数组点数组对是用来存储一些列点的列表的，后面很多其他的几何类型，底层都是用点数组来存储数据的。 1234567891011typedef struct{ //当前已经存储了多少个点 uint32_t npoints; //当前的空间最多容纳多少个点 uint32_t maxpoints; //标志位，使用FLAGS_*宏来操作 lwflags_t flags; //序列化后的点数组的首指针，结合上面的几个成员，可以解析出具体的数据 uint8_t *serialized_pointlist;} POINTARRAY; 4、序列化任何几何类型都可以被序列化存储起来，被序列化后就是一个包含了该几何类型所有信息的字节数组。所以就需要有一种序列化的规则，以一种展开平铺的结构，而不是人易于理解的那种类似树形结构的存储方式。先给出序列化结构在源码中的定义，在说后续： 1234567891011typedef struct{ //兼容PostgresSQL的边长类型，用VAR*宏来操作 uint32_t size; //24个bit来存储SRID uint8_t srid[3]; //标志位，是否有Z维、是否有M维、是否有BBox(Bounding Box)、是否是地理的 uint8_t gflags; //被学列化的字节数组(类似柔性数组) uint8_t data[1];} GSERIALIZED; 在liblwgeom目录下，有一个gserialized.txt文件来解释了序列化后的存储方式。下面先给出一些需要注意的内容： GSERIALIZED只是被PostGIS来使用的，其他使用几何库的程序（例如：loader和dumper程序）会将几何对象序列化维WKB、EWKB、可变长文本等。在结构体中的第一个字段是一个32位的size，就像PostgresSQL中的可变长类型似的。 递归的进行读/写的，所以对于嵌套的容器类型可以方便存储，并且对于递归深度，没有严格的限制。 保留了纵坐标数组双对齐，这使得坐标访问不需要内存拷贝（这个双对齐，有待考证是什么意思）。 强制性的包含了SRID，是因为意识到了大部分使用PostGIS的产品，也都需要使用SRID 在序列化的时候，把维度、SRID、边界框等信息放在最开始的位置。 在继续后面内容之前，先声明一个事情，GSERIALIZED在PostGIS中有两个版本（1和2）。我目前还没看到为什么会分为两个版本，并且也没看到这两个版本的被重用程度。为了简单和效率，我只选择一个版本的实现来看： GSERIALIZED只看版本2（V2）的实现！！！ 下面详细介绍以下GSERIALIZED结构体中每个字段意义： size：是为了兼容PostgreSQL中可变长类型的头部，可以使用SIZE_SET()和 SIZE_GET()宏进行操作。小心不要错误的设置了这个成员。 srid：SRID，用24位即可存下 gflags：用位掩码来存储信息，每个bit详细的意义如下 0x01:HasZ 0x02:HasM 0x04:HasBBox 0x08:IsGeodetic 0x10:Reserved（保留字段） 0x20:HasExtendedFlags（是否有扩展位） 0x40:VersionBit1（两个版本位） 0x80:VersionBit2 关于扩展字段就先不看了，那个特殊性比较强。 data：字节数组，用于存储具体的数据。下面给出几种几何类型的序列化存储方式： 点数组：&lt;npoints&gt;[double] [double] [double]… 线串： &lt;npoints&gt;[double] … [double] 多边形： &lt;nrings&gt; [double] … [double] 容器： &lt;ngeoms&gt;[geom] … [geom] 5、几何类型PostGIS中包含了许多种几何类型，现在我把它们全部列出来。 0. LWGEOM表示任意几何类型，是几何类型的抽象，可以看作是后续各种几何对象的“基类”。所有的几何对象都具有和LWGEOM基本一样的结构。或者说所有的几何对象都是LWGEOM的变体。 123456789101112131415typedef struct{ //边界框 GBOX *bbox; //存储几何对象数据的对象的指针，这个成员在不同对象中会不同，但都是指针 void *data; //SRID int32_t srid; //标志位 lwflags_t flags; //几何类型 uint8_t type; //内存补齐，目前没有使用 char pad[1]; }LWGEOM; 对几个字段进行一些补充说明： srid：SRID。和它相关的几个宏定义如下： 1234567891011//SRID的最大值#define SRID_MAXIMUM 999999//用户可以使用的最大SRID，保留1000个内部使用#define SRID_USER_MAXIMUM 998999#define SRID_UNKNOWN 0#define SRID_IS_UNKNOWN(x) ((int)x&lt;=0)//非法SRID，内部使用#define SRID_INVALID (999999 + 2)//默认的SRID，4326是地理类型#define SRID_DEFAULT 4326 flags：标志位，可以设置的有： 123456#define LWFLAG_Z 0x01#define LWFLAG_M 0x02#define LWFLAG_BBOX 0x04#define LWFLAG_GEODETIC 0x08#define LWFLAG_READONLY 0x10#define LWFLAG_SOLID 0x20 type：几何类型，有如下这么多种： 1234567891011121314151617#define POINTTYPE 1#define LINETYPE 2#define POLYGONTYPE 3#define MULTIPOINTTYPE 4#define MULTILINETYPE 5#define MULTIPOLYGONTYPE 6#define COLLECTIONTYPE 7#define CIRCSTRINGTYPE 8#define COMPOUNDTYPE 9#define CURVEPOLYTYPE 10#define MULTICURVETYPE 11#define MULTISURFACETYPE 12#define POLYHEDRALSURFACETYPE 13#define TRIANGLETYPE 14#define TINTYPE 15#define NUMTYPES 16 介绍完了这些，开始列出具体的几何类型了。前面遇到的字段，后面就不特别的去进行解释了。 1. LWPOINT-点123456789typedef struct{ GBOX *bbox; POINTARRAY *point; int32_t srid; lwflags_t flags; uint8_t type; /* POINTTYPE */ char pad[1]; }LWPOINT; 这里数据字段使用的是一个POINTARRAY，这个点数组中只存储一个点。这样做而不是直接用一个点结构体的好处是，可以把维度信息隐藏起来 2. LWLINE-线123456789typedef struct{ GBOX *bbox; POINTARRAY *points; int32_t srid; lwflags_t flags; uint8_t type; /* LINETYPE */ char pad[1];}LWLINE; 这里数据字段也是使用的POINTARRAY。因为线是由一个个的点连起来组成的，所以这里使用POINTARRAY很正确。 3. LWTRIANGLE-三角形123456789typedef struct{ GBOX *bbox; POINTARRAY *points; int32_t srid; lwflags_t flags; uint8_t type; char pad[1]; } LWTRIANGLE; 这种类型在我使用PostGIS的过程中并没有遇到过，应该是在一些较新的版本中添加的。 数据存储使用的还是POINTARRAY，不过这个应该是要保证点是首尾相连的。 4. LWCIRCSTRING-CircularString123456789typedef struct{ GBOX *bbox; POINTARRAY *points; int32_t srid; lwflags_t flags; uint8_t type; /* CIRCSTRINGTYPE */ char pad[1]; } LWCIRCSTRING; 这种我把它叫做圆环，数据存储依旧是POINTARRAY，应该要保证是一个闭合的圆圈的。这种类型应该是用来表示曲线的。 5. LWPOLY-多边形1234567891011typedef struct{ GBOX *bbox; POINTARRAY **rings; /* list of rings (list of points) */ int32_t srid; lwflags_t flags; uint8_t type; /* POLYGONTYPE */ char pad[1]; uint32_t nrings; /* how many rings we are currently storing */ uint32_t maxrings; /* how many rings we have space for in **rings */} LWPOLY; 多边形这个类型就有些特殊的变化了。 首先，数据存储使用的是POINTARRAY二级指针，即是有多个POINTARRAY组成的。我们知道多边形是由多个闭合的线串组成的，这样每个线串需要一个POINTARRAY，多个线串就需要多个POINTARRAY了。 其次，比LWGEOM多了两个字段，nrings和maxrings。这两个字段也都很好理解，前者表示当前存储了多少个环，后者表示当前几何对象已经申请的空间能够容纳的环的个数。 6. LWMPOINT-MultiPoint1234567891011typedef struct{ GBOX *bbox; LWPOINT **geoms; int32_t srid; lwflags_t flags; uint8_t type; /* MULTYPOINTTYPE */ char pad[1]; /* Padding to 24 bytes (unused) */ uint32_t ngeoms; /* how many geometries we are currently storing */ uint32_t maxgeoms; /* how many geometries we have space for in **geoms */} LWMPOINT; 多点，这个算是容器类型了，用来存储多个点几何对象。数据成员使用的是LWPOINT**，一个二级指针。因为是多个点，所以需要一个数组/列表来存每个点，这时第一级指针。而每个点都要使用一个指针来指向具体的对象，这时第二级指针。 ngeoms和maxgeoms：前者表示当前点的个数，后者表示当亲能容纳的点的个数。 7. LWMLINE-MultiLine1234567891011typedef struct{ GBOX *bbox; LWLINE **geoms; int32_t srid; lwflags_t flags; uint8_t type; /* MULTILINETYPE */ char pad[1]; /* Padding to 24 bytes (unused) */ uint32_t ngeoms; /* how many geometries we are currently storing */ uint32_t maxgeoms; /* how many geometries we have space for in **geoms */} LWMLINE; 多线串，这个也是容器类型，用来存储多个线串几何对象。每个字段的含义和之前的类似，不赘述了。 8. LWMPOLY-MultiPolygon1234567891011typedef struct{ GBOX *bbox; LWPOLY **geoms; int32_t srid; lwflags_t flags; uint8_t type; /* MULTIPOLYGONTYPE */ char pad[1]; /* Padding to 24 bytes (unused) */ uint32_t ngeoms; /* how many geometries we are currently storing */ uint32_t maxgeoms; /* how many geometries we have space for in **geoms */} LWMPOLY; 多多边形，容器类型。 9. LWCOLLECTION-Collection1234567891011typedef struct{ GBOX *bbox; LWGEOM **geoms; int32_t srid; lwflags_t flags; uint8_t type; /* COLLECTIONTYPE */ char pad[1]; /* Padding to 24 bytes (unused) */ uint32_t ngeoms; /* how many geometries we are currently storing */ uint32_t maxgeoms; /* how many geometries we have space for in **geoms */} LWCOLLECTION; 容器，可以存储各种不同的几何对象，任意一种。 10. LWCOMPOUND-复合类型1234567891011typedef struct{ GBOX *bbox; LWGEOM **geoms; int32_t srid; lwflags_t flags; uint8_t type; /* COLLECTIONTYPE */ char pad[1]; /* Padding to 24 bytes (unused) */ uint32_t ngeoms; /* how many geometries we are currently storing */ uint32_t maxgeoms; /* how many geometries we have space for in **geoms */} LWCOMPOUND; 我不知道这个的存在有什么意义，代码都是照搬COLLECTION的，连注释中的类型都忘了改。 11. LWCURVEPOLY-曲线多边形1234567891011typedef struct{ GBOX *bbox; LWGEOM **rings; int32_t srid; lwflags_t flags; uint8_t type; /* CURVEPOLYTYPE */ char pad[1]; /* Padding to 24 bytes (unused) */ uint32_t nrings; /* how many rings we are currently storing */ uint32_t maxrings; /* how many rings we have space for in **rings */} LWCURVEPOLY; 这个应该是用于表示曲线的多边形，而不是直线的。 12. LWMCURVE-多曲线1234567891011typedef struct{ GBOX *bbox; LWGEOM **geoms; int32_t srid; lwflags_t flags; uint8_t type; /* MULTICURVE */ char pad[1]; /* Padding to 24 bytes (unused) */ uint32_t ngeoms; /* how many geometries we are currently storing */ uint32_t maxgeoms; /* how many geometries we have space for in **geoms */} LWMCURVE; 用于存储多条曲线。 13. LWMSURFACE-MultiSurface1234567891011typedef struct{ GBOX *bbox; LWGEOM **geoms; int32_t srid; lwflags_t flags; uint8_t type; /* MULTISURFACETYPE */ char pad[1]; /* Padding to 24 bytes (unused) */ uint32_t ngeoms; /* how many geometries we are currently storing */ uint32_t maxgeoms; /* how many geometries we have space for in **geoms */} LWMSURFACE; 这里就有点疑惑了，surface应该是表面或者曲面的意思，但是之前并没有看到单个的这个东西的定义，怎么现在就直接冒出来多曲面的结构了？ 14. LWPSURFACE-PolyHedralSurface123456789101112typedef struct{ GBOX *bbox; LWPOLY **geoms; int32_t srid; lwflags_t flags; uint8_t type; /* POLYHEDRALSURFACETYPE */ char pad[1]; /* Padding to 24 bytes (unused) */ uint32_t ngeoms; /* how many geometries we are currently storing */ uint32_t maxgeoms; /* how many geometries we have space for in **geoms */}LWPSURFACE; 多面体表面 15. LWTIN-MultiTriangle1234567891011typedef struct{ GBOX *bbox; LWTRIANGLE **geoms; int32_t srid; lwflags_t flags; uint8_t type; /* TINTYPE */ char pad[1]; /* Padding to 24 bytes (unused) */ uint32_t ngeoms; /* how many geometries we are currently storing */ uint32_t maxgeoms; /* how many geometries we have space for in **geoms */} LWTIN; 用于存储多个三角形的东西。 至此PostGIS中所有的几何类型就都说完了。 接下来有一系列用于LW*类型–&gt;LWGEOM、LWGEOM–&gt;LW*类型的转换函数，它们的实现基本都差不多，我们只拿LWLINE举个例子： 1234567891011121314151617181920212223//liblwgeom.h//LWLINE和LWGEOM互相转换extern LWLINE *lwgeom_as_lwline(const LWGEOM *lwgeom);extern LWGEOM *lwline_as_lwgeom(const LWLINE *obj);//lwgeom.cLWLINE *lwgeom_as_lwline(const LWGEOM *lwgeom){ //保证指针不为空 if ( lwgeom == NULL ) return NULL; //保证LWGEOM确实是LWLINE类型 if ( lwgeom-&gt;type == LINETYPE ) //因为内存结构是相同的，所有做强制类型转换就可以了 return (LWLINE *)lwgeom; //如果不是LWLINE类型，则不能转换成功，返回NULL else return NULL;}LWGEOM *lwline_as_lwgeom(const LWLINE *obj){ //lw*--&gt;LWGEOM的转换就简单了，只要确保obj非空即可 if ( obj == NULL ) return NULL; return (LWGEOM *)obj;} 然后还有几个把单个几何类型添加到对应的容器类型中的函数： 12345678extern LWCOLLECTION* lwcollection_add_lwgeom(LWCOLLECTION *col, const LWGEOM *geom);extern LWMPOINT* lwmpoint_add_lwpoint(LWMPOINT *mobj, const LWPOINT *obj);extern LWMLINE* lwmline_add_lwline(LWMLINE *mobj, const LWLINE *obj);extern LWMPOLY* lwmpoly_add_lwpoly(LWMPOLY *mobj, const LWPOLY *obj);extern LWPSURFACE* lwpsurface_add_lwpoly(LWPSURFACE *mobj, const LWPOLY *obj);extern LWTIN* lwtin_add_lwtriangle(LWTIN *mobj, const LWTRIANGLE *obj);extern LWCOLLECTION* lwcollection_concat_in_place(LWCOLLECTION* col1, const LWCOLLECTION* col2); 这一系列的函数中，只有第一个具体的实现了细节，后面的那些都是调用的第一个函数： 12345//lwmpoly.cLWMPOLY* lwmpoly_add_lwpoly(LWMPOLY *mobj, const LWPOLY *obj){ return (LWMPOLY*)lwcollection_add_lwgeom((LWCOLLECTION*)mobj, (LWGEOM*)obj);} 因为geom对应collection，polygon对应multipolygon。在添加到容器的操作上区别不大，所以转而调用第一个函数是合理的。接下来看看它的具体实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//lwcollection.c//这个只是把geom直接加入到col中，并不会创建一份拷贝LWCOLLECTION* lwcollection_add_lwgeom(LWCOLLECTION *col, const LWGEOM *geom){ //保证两个指针都非空 if (!col || !geom) return NULL; //确保collection内部没有出现矛盾 if (!col-&gt;geoms &amp;&amp; (col-&gt;ngeoms || col-&gt;maxgeoms)) { lwerror(&quot;Collection is in inconsistent state. Null memory but non-zero collection counts.&quot;); return NULL; } //保证当前容器可以接受geom这个几何对象 if ( ! lwcollection_allows_subtype(col-&gt;type, geom-&gt;type) ) { lwerror(&quot;%s cannot contain %s element&quot;, lwtype_name(col-&gt;type), lwtype_name(geom-&gt;type)); return NULL; } //如果容器现在还没有初始化的话，现在就对它初始化 if (!col-&gt;geoms) { col-&gt;maxgeoms = 2; //初始化的时候，准备2个几何对象的空间 col-&gt;ngeoms = 0; col-&gt;geoms = lwalloc(col-&gt;maxgeoms * sizeof(LWGEOM*)); } //确保存在一个位置使得能够放下新添加的geom lwcollection_reserve(col, col-&gt;ngeoms + 1);#if PARANOIA_LEVEL &gt; 1 /* See http://trac.osgeo.org/postgis/ticket/2933 */ //保证容器中当前不存在这个geom { uint32_t i = 0; for (i = 0; i &lt; col-&gt;ngeoms; i++) { if (col-&gt;geoms[i] == geom) { lwerror(&quot;%s [%d] found duplicate geometry in collection %p == %p&quot;, __FILE__, __LINE__, col-&gt;geoms[i], geom); return col; } } }#endif //把新的geom放到容器的末尾 col-&gt;geoms[col-&gt;ngeoms] = (LWGEOM*)geom; col-&gt;ngeoms++; return col;} 这份代码逻辑很简单，其中的lwcollection_allows_subtype函数，是用于检测几何对象是否能加入到容器中，实现也很简单： 1234567891011int lwcollection_allows_subtype(int collectiontype, int subtype){ //直接用if判断子类型和容器类型是否对应 if ( collectiontype == COLLECTIONTYPE ) return LW_TRUE; if ( collectiontype == MULTIPOINTTYPE &amp;&amp; subtype == POINTTYPE ) return LW_TRUE; //后续省略....... return LW_FALSE;} 另外这个函数： 12345678void lwcollection_reserve(LWCOLLECTION *col, uint32_t ngeoms){ if ( ngeoms &lt;= col-&gt;maxgeoms ) return; //每次扩大两倍 do { col-&gt;maxgeoms *= 2; } while ( col-&gt;maxgeoms &lt; ngeoms ); //realloc内存 col-&gt;geoms = lwrealloc(col-&gt;geoms, sizeof(LWGEOM*) * col-&gt;maxgeoms);} 这个函数保证容器中有空间来容纳几个geom，如果盛不下的话，就把容量扩大，重新分配内存。这里的每次扩大两倍的这个技巧，在很多地方都被用到了。例如STL的vector扩容、redis的hash、libevent中等。 二、序列化PostGIS对于序列化提供了许多接口，这一节我们就来详细的看下各个接口。注意，基本上每个接口都实现了两个版本（v1和v2）。函数接口声明在liblwgeom.h中，实现在gserialized.c中，然后会继续根据该序列化对象的版本转而调用对应版本的实现，分别在gserialized1.c和gserialized2.c中。例如： 12345678910111213141516171819202122232425262728293031323334353637383940//liblwgeom.h 声明extern lwflags_t gserialized_get_lwflags(const GSERIALIZED *g);//gserialized.c 实现lwflags_t gserialized_get_lwflags(const GSERIALIZED *g){ //判断版本 if (GFLAGS_GET_VERSION(g-&gt;gflags)) return gserialized2_get_lwflags(g); else return gserialized1_get_lwflags(g);};//gserialized1.clwflags_t gserialized1_get_lwflags(const GSERIALIZED *g){ lwflags_t lwflags = 0; uint8_t gflags = g-&gt;gflags; FLAGS_SET_Z(lwflags, G1FLAGS_GET_Z(gflags)); FLAGS_SET_M(lwflags, G1FLAGS_GET_M(gflags)); FLAGS_SET_BBOX(lwflags, G1FLAGS_GET_BBOX(gflags)); FLAGS_SET_GEODETIC(lwflags, G1FLAGS_GET_GEODETIC(gflags)); FLAGS_SET_SOLID(lwflags, G1FLAGS_GET_SOLID(gflags)); return lwflags;}//gserialized2.clwflags_t gserialized2_get_lwflags(const GSERIALIZED *g){ lwflags_t lwflags = 0; uint8_t gflags = g-&gt;gflags; FLAGS_SET_Z(lwflags, G2FLAGS_GET_Z(gflags)); FLAGS_SET_M(lwflags, G2FLAGS_GET_M(gflags)); FLAGS_SET_BBOX(lwflags, G2FLAGS_GET_BBOX(gflags)); FLAGS_SET_GEODETIC(lwflags, G2FLAGS_GET_GEODETIC(gflags)); if (G2FLAGS_GET_EXTENDED(gflags)) { uint64_t xflags = 0; memcpy(&amp;xflags, g-&gt;data, sizeof(uint64_t)); FLAGS_SET_SOLID(lwflags, xflags &amp; G2FLAG_X_SOLID); } return lwflags;} 以上这份代码就是关于获取指定序列化对象的标志位的函数实现。所有的序列化的接口函数基本上都是这种实现方式，所以后面就不列出声明和第一层的实现了。再加上之前说过了，只看版本2的实现方式，所以后面的代码例子都是版本2的。 1、 gserialized_get_lwflags 获取标志位见上面。 2、gserialized_get_float_box_p 获取边界框12345678910111213141516const float * gserialized2_get_float_box_p(const GSERIALIZED *g, size_t *ndims){ //数据指针 uint8_t *ptr = (uint8_t*)(g-&gt;data); //计算维度，并返回 size_t bndims = G2FLAGS_NDIMS_BOX(g-&gt;gflags); if (ndims) *ndims = bndims; //判断有没有边界框，是由标志位来判断的 if (!(g &amp;&amp; gserialized_has_bbox(g))) return NULL; //有边界框，且有扩展字段，则要把数据指针前移，跳过扩展字段 if (gserialized2_has_extended(g)) ptr += 8; //现在ptr指向边界框了 return (const float *)(ptr);} 3、gserialized_get_type 获取几何类型从序列化形式中提取出几何类型。因为几何类型是隐藏再数据成员中的，所以这个函数是比较有意义的。 12345678910111213141516171819uint32_t gserialized2_get_type(const GSERIALIZED *g){ //获取序列化中几何对象的具体数据开始的位置指针 uint8_t *ptr = gserialized2_get_geometry_p(g); //类型是前4个字节 return *((uint32_t*)(ptr));}static inline uint8_t *gserialized2_get_geometry_p(const GSERIALIZED *g){ //计算是否有额外的字段 uint32_t extra_data_bytes = 0; //跳过扩展字段 if (gserialized2_has_extended(g)) extra_data_bytes += sizeof(uint64_t); //跳过边界框 if (gserialized2_has_bbox(g)) extra_data_bytes += gserialized2_box_size(g); //返回几何数据开始的指针 return ((uint8_t *)g-&gt;data) + extra_data_bytes;} 4、gserialized_max_header_size 获取序列化头部的最大长度这里的最大长度是指，在序列化后，几何数据之前的那部分的最大长度。 1234567891011uint32_t gserialized2_max_header_size(void){ //获取data字段前面部分的长度 static const intptr_t size_of_gserialized_up_to_data = (intptr_t) &amp; ((GSERIALIZED *)NULL)-&gt;data; /* GSERIALIZED size + max bbox according gbox_serialized_size (XYZM*2) + extended flags + type */ //总的长度为：结构体data前面的长度 + //GBOX的长度(XYZM)*2=8个float + //扩展字段 + //几何类型字段 return size_of_gserialized_up_to_data + 8 * sizeof(float) + sizeof(uint64_t) + sizeof(uint32_t);} 这个实现中一个非常神奇的地方：(intptr_t) &amp; ((GSERIALIZED *)NULL)-&gt;data;这句代码竟然能奇迹般的获取到data字段前面占用的空间大小，我自己也写了个例子测试了下，确实是这样。这个触及到知识盲区了，网上也没搜到是什么原理，先标记下来吧。 5、gserialized_hash 计算hash值这个是根据srid、类型、几何信息等进行计算的，具体的实现和hash算法就没必要看了。 6、gserialized_get_srid 获取SRID1234567891011121314int32_t gserialized2_get_srid(const GSERIALIZED *g){ //SRID用三个字节来存储的，用位运算把它们组合起来 int32_t srid = 0; srid = srid | (g-&gt;srid[0] &lt;&lt; 16); srid = srid | (g-&gt;srid[1] &lt;&lt; 8); srid = srid | (g-&gt;srid[2]); //SRID中只有21位有用，多余的可以被抹掉。下面这个操作是正确的，值得思考一下。 srid = (srid&lt;&lt;11)&gt;&gt;11; //判断是否合法 if (srid == 0) return SRID_UNKNOWN; else return srid;} 7、gserialized_set_srid 设置SRID12345678910void gserialized2_set_srid(GSERIALIZED *g, int32_t srid){ //如果传进来的srid是非法的，则把它变为PostGIS中规定的非法SRID srid = clamp_srid(srid); if (srid == SRID_UNKNOWN) srid = 0; //将SRID利用位运算分开存到三个字节中 g-&gt;srid[0] = (srid &amp; 0x001F0000) &gt;&gt; 16; g-&gt;srid[1] = (srid &amp; 0x0000FF00) &gt;&gt; 8; g-&gt;srid[2] = (srid &amp; 0x000000FF);} 8、gserialized_is_empty 检查是否为空这里为空，检查的是是否有几何对象存在。对于容器会一直递归找到一个具体的几何对象，没有的话，则为空。 1234567891011121314151617181920212223242526272829303132333435int gserialized2_is_empty(const GSERIALIZED *g){ int isempty = 0; //找到几何对象的位置 uint8_t *p = gserialized2_get_geometry_p(g); gserialized2_is_empty_recurse(p, &amp;isempty); return isempty;}//递归找是否存在一个非容器几何对象static size_t gserialized2_is_empty_recurse(const uint8_t *p, int *isempty){ int i; int32_t type, num; //分别拿到类型和数量 memcpy(&amp;type, p, 4); memcpy(&amp;num, p+4, 4); //容器则逐个递归 if (lwtype_is_collection(type)) { size_t lz = 8; for ( i = 0; i &lt; num; i++ ) { lz += gserialized2_is_empty_recurse(p+lz, isempty); if (!*isempty) return lz; } *isempty = LW_TRUE; return lz; } else //非容器则判断是否为空。 { *isempty = (num == 0 ? LW_TRUE : LW_FALSE); return 8; }} 9、判断是否有某个标志12345extern int gserialized_has_bbox(const GSERIALIZED *gser);extern int gserialized_has_z(const GSERIALIZED *gser);extern int gserialized_has_m(const GSERIALIZED *gser);extern int gserialized_is_geodetic(const GSERIALIZED *gser);extern int gserialized_ndims(const GSERIALIZED *gser); 这一系列的接口只是根据flags中的位来判断的，根据函数名字即可知道作用，所以不展开看了。 10、gserialized_cmp 比较两个序列化的对象大小这里只说一下比较的规则吧，就不贴代码了： 根据是否有边界框比较，有&gt;没有 都有边界框，根据边界框的hash值大小比较 都没有边界框，根据数据体大小比较 根据SRID大小比较 根据有无Z维比较 根据有无M维比较 11、gserialized_from_lwgeom 序列化对一个LWGEOM对象进行序列化，创建一个GSERIALIZED对象。对于所有的非点类型，会计算一个边界框，插入到序列化中。geodetic标志位会用于控制边框的计算方法是笛卡尔的还是地心的。 12345678910111213141516171819202122232425262728293031GSERIALIZED* gserialized2_from_lwgeom(LWGEOM *geom, size_t *size){ //验证是否存在边界框，或者是否需要边界框，规则基本上就是点类型不需要 if ((!geom-&gt;bbox) &amp;&amp; lwgeom_needs_bbox(geom) &amp;&amp; (!lwgeom_is_empty(geom))) lwgeom_add_bbox(geom); //设置BBOX标志位 FLAGS_SET_BBOX(geom-&gt;flags, (geom-&gt;bbox ? 1 : 0)); //计算被序列化后的大小，然后申请内存具体规则略。 expected_size = gserialized2_from_lwgeom_size(geom); ptr = lwalloc(expected_size); g = (GSERIALIZED*)(ptr); //设置序列化对象的SRID gserialized2_set_srid(g, geom-&gt;srid); //设置序列化对象的大小 SIZE_SET(g-&gt;size, expected_size); //由lw标志位获得gserialized2标志位 g-&gt;gflags = lwflags_get_g2flags(geom-&gt;flags); //跳过size、srid、flags字段 ptr += 8; //填充并跳过扩展字段 ptr += gserialized2_from_extended_flags(geom-&gt;flags, ptr); //填充并跳过边界框字段 if (geom-&gt;bbox) ptr += gserialized2_from_gbox(geom-&gt;bbox, ptr); //重头戏，对象数据序列化 ptr += gserialized2_from_lwgeom_any(geom, ptr); //计算序列化对象的大小，返回。 ...... return g;} 上面的gserialized2_from_lwgeom_any函数是具体进行几何对象序列化的，看下实现： 123456789101112131415161718static size_t gserialized2_from_lwgeom_any(const LWGEOM *geom, uint8_t *buf){ switch (geom-&gt;type) { case POINTTYPE: return gserialized2_from_lwpoint((LWPOINT *)geom, buf); case LINETYPE: return gserialized2_from_lwline((LWLINE *)geom, buf); //中间那些其他类型的省略掉，节省篇幅 ...... case COLLECTIONTYPE: return gserialized2_from_lwcollection((LWCOLLECTION *)geom, buf); default: lwerror(&quot;Unknown geometry type: %d - %s&quot;, geom-&gt;type, lwtype_name(geom-&gt;type)); return 0; } return 0;} 从代码上可以看到，每种类型都有一个对应的序列化函数，我们以LWLINE为例看看： 123456789101112131415161718192021static size_t gserialized2_from_lwline(const LWLINE *line, uint8_t *buf){ //略去一些不重要的代码....... //根据维度计算每个点的大小 ptsize = ptarray_point_size(line-&gt;points); loc = buf; //线设置类型字段 memcpy(loc, &amp;type, sizeof(uint32_t)); loc += sizeof(uint32_t); //设置数量字段 memcpy(loc, &amp;(line-&gt;points-&gt;npoints), sizeof(uint32_t)); loc += sizeof(uint32_t); if (line-&gt;points-&gt;npoints &gt; 0) { //所有点的大小 size = line-&gt;points-&gt;npoints * ptsize; //将点的数据直接内存拷贝到指定位置 memcpy(loc, getPoint_internal(line-&gt;points, 0), size); loc += size; } return (size_t)(loc - buf);} 对于容器类型的序列化，也会先填充好对象数据之前的字段，在递归的序列化每个几何对象。 12、lwgeom_from_gserialized 反序列化对 GSERIALIZED进行反序列化，并创建一个新的LWGEOM。 1234567891011121314151617181920212223242526272829303132333435363738LWGEOM* lwgeom_from_gserialized2(const GSERIALIZED *g){ //获取SRID、几何类型、标志位 srid = gserialized2_get_srid(g); lwtype = gserialized2_get_type(g); lwflags = gserialized2_get_lwflags(g); data_ptr = (uint8_t*)g-&gt;data; //跳过扩展字段 if (G2FLAGS_GET_EXTENDED(g-&gt;gflags)) data_ptr += sizeof(uint64_t); //跳过GBOX字段 if (FLAGS_GET_BBOX(lwflags)) data_ptr += gbox_serialized_size(lwflags); //将几何数据反序列化出来，并创建一个LWGEOM，稍后还是以LWLINE为例看下 lwgeom = lwgeom_from_gserialized2_buffer(data_ptr, lwflags, &amp;size); //是否创建成功 if (!lwgeom) lwerror(&quot;%s: unable create geometry&quot;, __func__); /* Ooops! */ lwgeom-&gt;type = lwtype; lwgeom-&gt;flags = lwflags; //读取GBOX并设置到LWGEOM if (gserialized2_read_gbox_p(g, &amp;bbox) == LW_SUCCESS) { lwgeom-&gt;bbox = gbox_copy(&amp;bbox); } //没有读取成功，则直接计算出来 else if (lwgeom_needs_bbox(lwgeom) &amp;&amp; (lwgeom_calculate_gbox(lwgeom, &amp;bbox) == LW_SUCCESS)) { lwgeom-&gt;bbox = gbox_copy(&amp;bbox); } else //不需要GBOX { lwgeom-&gt;bbox = NULL; } lwgeom_set_srid(lwgeom, srid); return lwgeom;} 在上面代码中的lwgeom_from_gserialized2_buffer，是对几何数据做反序列化的： 123456789101112131415LWGEOM* lwgeom_from_gserialized2_buffer(uint8_t *data_ptr, lwflags_t lwflags, size_t *g_size){ type = gserialized2_get_uint32_t(data_ptr); switch (type) { case POINTTYPE: return (LWGEOM *)lwpoint_from_gserialized2_buffer(data_ptr, lwflags, g_size); case LINETYPE: return (LWGEOM *)lwline_from_gserialized2_buffer(data_ptr, lwflags, g_size); //中间那些其他类型的省略掉，节省篇幅 .... case COLLECTIONTYPE: return (LWGEOM *)lwcollection_from_gserialized2_buffer(data_ptr, lwflags, g_size); }} 还是以LWLINE为例看下实现： 123456789101112131415161718192021222324static LWLINE* lwline_from_gserialized2_buffer(uint8_t *data_ptr, lwflags_t lwflags, size_t *size){ //创建一个LWLINE，做一些简单的初始化 line = (LWLINE*)lwalloc(sizeof(LWLINE)); line-&gt;srid = SRID_UNKNOWN; line-&gt;bbox = NULL; //设置类型和标志位 line-&gt;type = LINETYPE; line-&gt;flags = lwflags; //读取点数量 data_ptr += 4; /* Skip past the type. */ npoints = gserialized2_get_uint32_t(data_ptr); /* Zero =&gt; empty geometry */ data_ptr += 4; /* Skip past the npoints. */ //从字节数据构造POINTARRAY，之后会看到下面函数的实现的 if (npoints &gt; 0) line-&gt;points = ptarray_construct_reference_data(FLAGS_GET_Z(lwflags), FLAGS_GET_M(lwflags), npoints, data_ptr); else line-&gt;points = ptarray_construct(FLAGS_GET_Z(lwflags), FLAGS_GET_M(lwflags), 0); /* Empty linestring */ //结束 data_ptr += FLAGS_NDIMS(lwflags) * npoints * sizeof(double); //设置已读取的大小 if (size) *size = data_ptr - start_ptr; return line;} 13、获取GBOX12extern int gserialized_get_gbox_p(const GSERIALIZED *g, GBOX *box);extern int gserialized_fast_gbox_p(const GSERIALIZED *g, GBOX *box); 这里有两个函数功能相似，不同之处在于，前者如果没有找到GBOX会创建并计算出一个GBOX，后者不会。 1234567891011121314151617181920int gserialized2_get_gbox_p(const GSERIALIZED *g, GBOX *box){ //尝试从GSERIALIZED中读取GBOX if (gserialized2_read_gbox_p(g, box) == LW_SUCCESS) return LW_SUCCESS; //这里是一种优化方法，不用创建LWGEOM而通过一些技巧来计算GBOX else if (gserialized2_peek_gbox_p(g, box) == LW_SUCCESS) { return LW_SUCCESS; } //实在没有GBOX了，只能从GSERIALIZED导出LWGEOM，再计算GBOX else { LWGEOM *lwgeom = lwgeom_from_gserialized(g); int ret = lwgeom_calculate_gbox(lwgeom, box); gbox_float_round(box); lwgeom_free(lwgeom); return ret; }} 14、gserialized2_set_gbox 更新GBOX1extern GSERIALIZED *gserialized_set_gbox(GSERIALIZED *g, GBOX *gbox); 把GSERIALIZED中的GBOX更新，如果现有空间不足以容纳新的GBOX的话，会创建一个新的GSERIALIZED。所以有可能导致输入和输出不同。并且输入的内容应该由调用者释放掉。 15、gserialized_drop_gbox 删除GBOX1extern GSERIALIZED* gserialized_drop_gbox(GSERIALIZED *g); 删除掉GSERIALIZED中的GBOX，每次都会返回一个新的GSERIALIZED。 16、gserialized_peek_first_point 提取第一个点1extern int gserialized_peek_first_point(const GSERIALIZED *g, POINT4D *out_point); 提取几何对象中的第一个点。这个函数只对点几何对象有用，其他类型会返回失败。 至此，序列化的相关内容就完了。 这篇文章也到此为止。","link":"/2020/05/31/read-postgis-code-1/"},{"title":"PostGIS源码-2-LWGEOM库之几何对象的空间操作函数","text":"这是阅读LWGEOM库源码的第二篇文章。在这篇中，来看一下liblwgeom.h中剩下的用于几何操作的空间函数。我会只挑一些感兴趣的函数记录一下。不会把所有的函数都写一遍，太多了。 1、几何对象的边界框12345678910//释放掉BBOX，并去掉对应的标志extern void lwgeom_drop_bbox(LWGEOM *lwgeom);//为几何对象添加边界框，如果已经有了边界框，直接返回extern void lwgeom_add_bbox(LWGEOM *lwgeom);//刷新边界框--&gt;释放掉当前边界框，重新添加新的extern void lwgeom_refresh_bbox(LWGEOM *lwgeom);//递归的为每个几何对象及子对象添加边界框extern void lwgeom_add_bbox_deep(LWGEOM *lwgeom, GBOX *gbox);//返回几何对象的边界框，没有的话会创建extern const GBOX *lwgeom_get_bbox(const LWGEOM *lwgeom); 关于边界框，在PostGIS中可以叫做GBOX、BBOX。在上一篇文章中，GBOX的结构中，就是包含了维度信息（flags）和每个维度的最大最小值。那么边界框的计算也就好说了，就是计算出每个几何对象的每个点的每个坐标的最大最小值而已。 2、获取/设置POINTARRAY中的点1234567891011//读取PointArray种的第n个某种维度的点extern POINT4D getPoint4d(const POINTARRAY *pa, uint32_t n);extern int getPoint4d_p(const POINTARRAY *pa, uint32_t n, POINT4D *point);extern POINT3DZ getPoint3dz(const POINTARRAY *pa, uint32_t n);extern POINT3DM getPoint3dm(const POINTARRAY *pa, uint32_t n);extern int getPoint3dz_p(const POINTARRAY *pa, uint32_t n, POINT3DZ *point);extern int getPoint3dm_p(const POINTARRAY *pa, uint32_t n, POINT3DM *point);extern POINT2D getPoint2d(const POINTARRAY *pa, uint32_t n);extern int getPoint2d_p(const POINTARRAY *pa, uint32_t n, POINT2D *point);//把PointArray中的第n个点设置为指定的点extern void ptarray_set_point4d(POINTARRAY *pa, uint32_t n, const POINT4D *p4d); PointArray中存放的是一些维度相同的点，上面这些函数无非就是读取/设置字节数组中指定位置的值，以ptarray_set_point4d为例看下： 123456789101112131415161718192021222324voidptarray_set_point4d(POINTARRAY *pa, uint32_t n, const POINT4D *p4d){ //获取第n个点开始的位置 uint8_t *ptr; ptr = getPoint_internal(pa, n); //根据维度来设置不同的字节数 switch ( FLAGS_GET_ZM(pa-&gt;flags) ) { case 3: //4D memcpy(ptr, p4d, sizeof(POINT4D)); break; case 2: //3DZ memcpy(ptr, p4d, sizeof(POINT3DZ)); break; case 1: //3DM memcpy(ptr, p4d, sizeof(POINT2D)); ptr+=sizeof(POINT2D); memcpy(ptr, &amp;(p4d-&gt;m), sizeof(double)); break; case 0: //2 memcpy(ptr, p4d, sizeof(POINT2D)); break; }} 3、PointArray构造及操纵函数1234567//ptarray.c//构造一个空的POINTARRAYextern POINTARRAY* ptarray_construct(char hasz, char hasm, uint32_t npoints);extern POINTARRAY* ptarray_construct_empty(char hasz, char hasm, uint32_t maxpoints);//构造POINTARRAY，并且把一些点放进去extern POINTARRAY* ptarray_construct_copy_data(char hasz, char hasm, uint32_t npoints, const uint8_t *ptlist);extern POINTARRAY* ptarray_construct_reference_data(char hasz, char hasm, uint32_t npoints, uint8_t *ptlist); 构造的原理都差不多，先为PointArray结构申请空间，再为点列表申请空间。以ptarray_construct_empty为例看下实现： 1234567891011121314151617POINTARRAY*ptarray_construct_empty(char hasz, char hasm, uint32_t maxpoints){ //创建POINTARRAY结构体 POINTARRAY *pa = lwalloc(sizeof(POINTARRAY)); pa-&gt;serialized_pointlist = NULL; //设置标志位，其实就是维度信息而已 pa-&gt;flags = lwflags(hasz, hasm, 0); //初始化为空 pa-&gt;npoints = 0; pa-&gt;maxpoints = maxpoints; if ( maxpoints &gt; 0 ) //为点列表申请足够的空间 pa-&gt;serialized_pointlist = lwalloc(maxpoints * ptarray_point_size(pa)); else pa-&gt;serialized_pointlist = NULL; return pa;} 然后是一系列查看点数组是否是一个闭合的环的函数，这类函数再许多地方会被用到。例如多边形的环需要是闭合的。原理也很简单，只需要判断第一个点和最后一个点是否重合，这里重合的判定准则是两个点内存完全一样为重合。 1234extern int ptarray_is_closed(const POINTARRAY *pa);extern int ptarray_is_closed_2d(const POINTARRAY *pa);extern int ptarray_is_closed_3d(const POINTARRAY *pa);extern int ptarray_is_closed_z(const POINTARRAY *pa); 4、单独的几何体添加成员标题的意思是，举个例子：线串添加点，多边形添加环，这样子。这一节列举下这种类型的函数： 1234int lwline_add_lwpoint(LWLINE *line, LWPOINT *point, uint32_t where);int lwpoly_add_ring(LWPOLY *poly, POINTARRAY *pa);int lwcurvepoly_add_ring(LWCURVEPOLY *poly, LWGEOM *ring);int lwcompound_add_lwgeom(LWCOMPOUND *comp, LWGEOM *geom); 这几个函数是同一种类型，基本原理都是添加一个新的元素到元素列表中。原理基本就是先为新元素预备好空间，空间不够则申请，然后将新元素添加进去。我们以多边形添加环为例看下： 123456789101112131415161718intlwpoly_add_ring(LWPOLY *poly, POINTARRAY *pa){ //确保参数合法 if( ! poly || ! pa ) return LW_FAILURE; //空间不够 if( poly-&gt;nrings &gt;= poly-&gt;maxrings ) { //容量扩大两倍 int new_maxrings = 2 * (poly-&gt;nrings + 1); poly-&gt;rings = lwrealloc(poly-&gt;rings, new_maxrings * sizeof(POINTARRAY*)); poly-&gt;maxrings = new_maxrings; } //将新的环放到末尾 poly-&gt;rings[poly-&gt;nrings] = pa; poly-&gt;nrings++; return LW_SUCCESS;} 5、内存释放函数内存释放函数可以分为两类：lw*_free和lw*_release。区别是free是把对象相关的所有内存都释放掉。release不会释放几何对象的具体数据，而把具体数据之外的所有内存都释放掉。具体以多边形为例看下这两种内存释放函数： 1234567891011121314151617181920212223242526272829void lwpoly_free(LWPOLY* poly){ //如果由边界框，则释放掉 if (poly-&gt;bbox) lwfree(poly-&gt;bbox); //多边形是由环组成的 if ( poly-&gt;rings ) { //把构成每个环的PointArray释放掉 for (t = 0; t &lt; poly-&gt;nrings; t++) if (poly-&gt;rings[t]) ptarray_free(poly-&gt;rings[t]); //释放掉环这个成员变量占用的空间 lwfree(poly-&gt;rings); } //释放掉多边形这个结构体占用的空间。 lwfree(poly);}void lwpoly_release(LWPOLY *lwpoly){ //release型的释放函数都是转而调用lwgeom_release的 lwgeom_release(lwpoly_as_lwgeom(lwpoly));}void lwgeom_release(LWGEOM *lwgeom){ //释放边界框 if ( lwgeom-&gt;bbox ) { lwfree(lwgeom-&gt;bbox); } //释放几何对象那个结构体所占用的内存 lwfree(lwgeom);} 6、辅助打印函数PostGIS工具库中提供了几个打印几何对象数据的接口，如果需要调试的话，调用这些接口就好，不用自己每个去写了。 12345678extern void printBOX3D(BOX3D *b);extern void printPA(POINTARRAY *pa);extern void printLWPOINT(LWPOINT *point);extern void printLWLINE(LWLINE *line);extern void printLWPOLY(LWPOLY *poly);extern void printLWTRIANGLE(LWTRIANGLE *triangle);extern void printLWPSURFACE(LWPSURFACE *psurf);extern void printLWTIN(LWTIN *tin); 7、真 · 空间几何函数这一节列出的都是偏向于数学的，几何计算的函数。而正是由于这个原因，这些函数对于数学的要求高于编程，所以不去深入的看这些了，只把它们列举出来，等以后遇到了，再针对每个场景的特殊情况去看其实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152extern double distance2d_pt_pt(const POINT2D *p1, const POINT2D *p2);extern double distance2d_sqr_pt_seg(const POINT2D *p, const POINT2D *A, const POINT2D *B);extern LWGEOM* lwgeom_closest_line(const LWGEOM *lw1, const LWGEOM *lw2);extern LWGEOM* lwgeom_furthest_line(const LWGEOM *lw1, const LWGEOM *lw2);extern LWGEOM* lwgeom_closest_point(const LWGEOM *lw1, const LWGEOM *lw2);extern LWGEOM* lwgeom_furthest_point(const LWGEOM *lw1, const LWGEOM *lw2);extern double lwgeom_mindistance2d(const LWGEOM *lw1, const LWGEOM *lw2);extern double lwgeom_mindistance2d_tolerance(const LWGEOM *lw1, const LWGEOM *lw2, double tolerance);extern double lwgeom_maxdistance2d(const LWGEOM *lw1, const LWGEOM *lw2);extern double lwgeom_maxdistance2d_tolerance(const LWGEOM *lw1, const LWGEOM *lw2, double tolerance);/* 3D */extern double distance3d_pt_pt(const POINT3D *p1, const POINT3D *p2);extern double distance3d_pt_seg(const POINT3D *p, const POINT3D *A, const POINT3D *B);extern LWGEOM* lwgeom_furthest_line_3d(LWGEOM *lw1, LWGEOM *lw2);extern LWGEOM* lwgeom_closest_line_3d(const LWGEOM *lw1, const LWGEOM *lw2);extern LWGEOM* lwgeom_closest_point_3d(const LWGEOM *lw1, const LWGEOM *lw2);extern double lwgeom_mindistance3d(const LWGEOM *lw1, const LWGEOM *lw2);extern double lwgeom_mindistance3d_tolerance(const LWGEOM *lw1, const LWGEOM *lw2, double tolerance);extern double lwgeom_maxdistance3d(const LWGEOM *lw1, const LWGEOM *lw2);extern double lwgeom_maxdistance3d_tolerance(const LWGEOM *lw1, const LWGEOM *lw2, double tolerance);extern double lwgeom_area(const LWGEOM *geom);extern double lwgeom_length(const LWGEOM *geom);extern double lwgeom_length_2d(const LWGEOM *geom);extern double lwgeom_perimeter(const LWGEOM *geom);extern double lwgeom_perimeter_2d(const LWGEOM *geom);extern int lwgeom_dimension(const LWGEOM *geom);extern LWPOINT* lwline_get_lwpoint(const LWLINE *line, uint32_t where);extern LWPOINT* lwcircstring_get_lwpoint(const LWCIRCSTRING *circ, uint32_t where);extern LWPOINT* lwcompound_get_startpoint(const LWCOMPOUND *lwcmp);extern LWPOINT* lwcompound_get_endpoint(const LWCOMPOUND *lwcmp);extern LWPOINT* lwcompound_get_lwpoint(const LWCOMPOUND *lwcmp, uint32_t where);extern double ptarray_length_2d(const POINTARRAY *pts);extern int pt_in_ring_2d(const POINT2D *p, const POINTARRAY *ring);extern int azimuth_pt_pt(const POINT2D *p1, const POINT2D *p2, double *ret);extern int lwpoint_inside_circle(const LWPOINT *p, double cx, double cy, double rad);extern LWGEOM* lwgeom_reverse(const LWGEOM *lwgeom);extern char* lwgeom_summary(const LWGEOM *lwgeom, int offset);extern char* lwpoint_to_latlon(const LWPOINT *p, const char *format);extern int lwgeom_startpoint(const LWGEOM* lwgeom, POINT4D* pt);extern void interpolate_point4d(const POINT4D *A, const POINT4D *B, POINT4D *I, double F);//确保外环是顺时针，而所有内环是逆时针extern int lwgeom_is_clockwise(LWGEOM *lwgeom); 8、几何对象拷贝函数1234567//浅拷贝extern LWGEOM *lwgeom_clone(const LWGEOM *lwgeom);extern POINTARRAY * ptarray_clone(const POINTARRAY *in)//深拷贝extern LWGEOM *lwgeom_clone_deep(const LWGEOM *lwgeom);extern POINTARRAY *ptarray_clone_deep(const POINTARRAY *ptarray);POINTARRAY *ptarray_clone(const POINTARRAY *in) 浅拷贝的函数，不会拷贝底层的序列化点数组。深拷贝会拷贝所有东西。核心区别在于PointArray的拷贝，我们看下它的深浅拷贝分别是如何实现的： 1234567891011121314151617181920212223242526272829303132333435//ptarray.cPOINTARRAY *ptarray_clone_deep(const POINTARRAY *in){ //创建并初始化新的ptarray。 POINTARRAY *out = lwalloc(sizeof(POINTARRAY)); out-&gt;flags = in-&gt;flags; out-&gt;npoints = in-&gt;npoints; out-&gt;maxpoints = in-&gt;npoints; FLAGS_SET_READONLY(out-&gt;flags, 0); if (!in-&gt;npoints) { //没有点的话，不需要初始化数据成员 out-&gt;serialized_pointlist = NULL; } else { //为数据成员申请内存，并对输入参数进行拷贝 size_t size = in-&gt;npoints * ptarray_point_size(in); out-&gt;serialized_pointlist = lwalloc(size); memcpy(out-&gt;serialized_pointlist, in-&gt;serialized_pointlist, size); } return out;}POINTARRAY *ptarray_clone(const POINTARRAY *in){ //开始的这些同上 POINTARRAY *out = lwalloc(sizeof(POINTARRAY)); out-&gt;flags = in-&gt;flags; out-&gt;npoints = in-&gt;npoints; out-&gt;maxpoints = in-&gt;maxpoints; FLAGS_SET_READONLY(out-&gt;flags, 1); //！！！区别：这里直接引用了输入参数的底层数据 out-&gt;serialized_pointlist = in-&gt;serialized_pointlist; return out;} 9、几何对象构造函数PostGIS中的几何对象标准构造函数有两种形式：lw*_construct和lw*_construct_empty，后者创建一个空的不包含几何数据的几何对象。前者创建一个几何对象，并提供一些参数作为它的底层数据。看下： 12345678910111213141516171819202122extern LWPOINT* lwpoint_construct(int32_t srid, GBOX *bbox, POINTARRAY *point);extern LWMPOINT *lwmpoint_construct(int32_t srid, const POINTARRAY *pa);extern LWLINE* lwline_construct(int32_t srid, GBOX *bbox, POINTARRAY *points);extern LWCIRCSTRING* lwcircstring_construct(int32_t srid, GBOX *bbox, POINTARRAY *points);extern LWPOLY* lwpoly_construct(int32_t srid, GBOX *bbox, uint32_t nrings, POINTARRAY **points);extern LWCURVEPOLY* lwcurvepoly_construct(int32_t srid, GBOX *bbox, uint32_t nrings, LWGEOM **geoms);extern LWTRIANGLE* lwtriangle_construct(int32_t srid, GBOX *bbox, POINTARRAY *points);extern LWCOLLECTION* lwcollection_construct(uint8_t type, int32_t srid, GBOX *bbox, uint32_t ngeoms, LWGEOM **geoms);//空几何对象构造函数extern LWGEOM* lwgeom_construct_empty(uint8_t type, int32_t srid, char hasz, char hasm);extern LWPOINT* lwpoint_construct_empty(int32_t srid, char hasz, char hasm);extern LWLINE* lwline_construct_empty(int32_t srid, char hasz, char hasm);extern LWPOLY* lwpoly_construct_empty(int32_t srid, char hasz, char hasm);extern LWCURVEPOLY* lwcurvepoly_construct_empty(int32_t srid, char hasz, char hasm);extern LWCIRCSTRING* lwcircstring_construct_empty(int32_t srid, char hasz, char hasm);extern LWCOMPOUND* lwcompound_construct_empty(int32_t srid, char hasz, char hasm);extern LWTRIANGLE* lwtriangle_construct_empty(int32_t srid, char hasz, char hasm);extern LWMPOINT* lwmpoint_construct_empty(int32_t srid, char hasz, char hasm);extern LWMLINE* lwmline_construct_empty(int32_t srid, char hasz, char hasm);extern LWMPOLY* lwmpoly_construct_empty(int32_t srid, char hasz, char hasm);extern LWCOLLECTION* lwcollection_construct_empty(uint8_t type, int32_t srid, char hasz, char hasm); 注：这里的构造函数是我为了方便这么叫的，它和C++中的构造函数没有关系。 下面我们以点为例，看下两种函数的实现： 12345678910111213141516171819202122232425262728293031//lwpoint.cLWPOINT *lwpoint_construct(int32_t srid, GBOX *bbox, POINTARRAY *point){ //创建一个对象并进行一些初始化 result = lwalloc(sizeof(LWPOINT)); result-&gt;type = POINTTYPE; FLAGS_SET_Z(flags, FLAGS_GET_Z(point-&gt;flags)); FLAGS_SET_M(flags, FLAGS_GET_M(point-&gt;flags)); //如果指定了边界框，那么要设置边界框标志位 FLAGS_SET_BBOX(flags, bbox?1:0); result-&gt;flags = flags; result-&gt;srid = srid; //指定了点数组作为底层数据，直接引用该数据 result-&gt;point = point; //使用指定的边界框 result-&gt;bbox = bbox; return result;}LWPOINT *lwpoint_construct_empty(int32_t srid, char hasz, char hasm){ //创建一个对象并进行一些初始化 LWPOINT *result = lwalloc(sizeof(LWPOINT)); result-&gt;type = POINTTYPE; result-&gt;flags = lwflags(hasz, hasm, 0); result-&gt;srid = srid; //这里会创建一个空的PointArray result-&gt;point = ptarray_construct(hasz, hasm, 0); //空的对象，自然没有边界框 result-&gt;bbox = NULL; return result;} 10、几何对象的通用序列化（1）这里的通用序列化和上篇文章中说的GSERIALIZED序列化的区别是，后者是只在PostGIS内部使用，而前者可以与其他用户交互。 可以将几何对象序列化为几种形式，例如：gml2、gml3、kml2、geojson等（我目前也不懂这些编码）。它们能够按照一些规定，把几何对象转换为文字形式，以及从文字转换为几何对象。就是序列化和反序列化。这些实现更多的是涉及对应的那种格式编码的算法，所以这里也不深入去看实现了，也没必要去读懂那些编码的实现。所以只把这些函数接口给列出来： 123456789101112extern char* lwgeom_to_gml2(const LWGEOM *geom, const char *srs, int precision, const char *prefix);extern char* lwgeom_extent_to_gml2(const LWGEOM *geom, const char *srs, int precision, const char *prefix);extern char* lwgeom_to_gml3(const LWGEOM *geom, const char *srs, int precision, int opts, const char *prefix, const char *id);extern char* lwgeom_extent_to_gml3(const LWGEOM *geom, const char *srs, int precision, int opts, const char *prefix);extern char* lwgeom_to_kml2(const LWGEOM *geom, int precision, const char *prefix);extern char* lwgeom_to_geojson(const LWGEOM *geo, char *srs, int precision, int has_bbox);extern char* lwgeom_to_svg(const LWGEOM *geom, int precision, int relative);extern char* lwgeom_to_x3d3(const LWGEOM *geom, char *srs, int precision, int opts, const char *defid);extern char* lwgeom_to_encoded_polyline(const LWGEOM *geom, int precision);extern LWGEOM* lwgeom_from_geojson(const char *geojson, char **srs);extern LWGEOM* lwgeom_from_encoded_polyline(const char *encodedpolyline, int precision); 再后面还有其他几种序列化的形式，例如WKT、WKB、EWKT等。 注：接下来本来应该是球体相关的一些函数，但我们现在不关心曲面几何，所以先跳过了。 11、点迭代器点迭代器，是PostGIS实现的为了方便访问多个几何对象的底层的点而实现的一个东西。底层实现是使用链表的前插法来模拟栈。维护两个栈，一个是存几何对象的栈，一个是存当前点数组的栈。然后每次访问点数组的栈，如果点数组的栈访问完了，就去几何对象的栈中提取出一个几何对象，并把它的点数组提取出来，并填充到店数组的栈中。下面先给出点迭代器提供的接口： 1234567891011//创建点迭代器，前者是只读，后者可以读写extern LWPOINTITERATOR* lwpointiterator_create(const LWGEOM* g);extern LWPOINTITERATOR* lwpointiterator_create_rw(LWGEOM* g);//销毁extern void lwpointiterator_destroy(LWPOINTITERATOR* s);//访问下一个点，这种接口在C++和Java中经常可以看到。extern int lwpointiterator_has_next(LWPOINTITERATOR* s);extern int lwpointiterator_next(LWPOINTITERATOR* s, POINT4D* p);extern int lwpointiterator_peek(LWPOINTITERATOR* s, POINT4D* p);//修改下一个点为指定的点extern int lwpointiterator_modify_next(LWPOINTITERATOR* s, const POINT4D* p); 这些接口的实现没必要都贴出来，我只拿创建的操作来看一下，整个创建的过程基本上就包含了大部分的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//lwiterator.c//链表的定义，用链表模拟栈struct LISTNODE{ struct LISTNODE* next; void* item;};typedef struct LISTNODE LISTNODE;//点迭代器的定义struct LWPOINTITERATOR{ //存几何对象的栈 LISTNODE* geoms; //存点数组的栈 LISTNODE* pointarrays; //迭代器当前位置 uint32_t i; //只读 char allow_modification;};//创建迭代器LWPOINTITERATOR* lwpointiterator_create_rw(LWGEOM* g){ //创建一个迭代器对象，并进行一些初始化 LWPOINTITERATOR* it = lwalloc(sizeof(LWPOINTITERATOR)); it-&gt;geoms = NULL; it-&gt;pointarrays = NULL; it-&gt;i = 0; it-&gt;allow_modification = LW_TRUE; //把给定的几何对象加入到迭代器中，仅仅是加入到栈中 add_lwgeom_to_stack(it, g); //把迭代器向前一步，在这里执行这个是因为当前 lwpointiterator_advance(it); return it;}//////////以下都是迭代器内部使用的函数了///////////static int add_lwgeom_to_stack(LWPOINTITERATOR* s, LWGEOM* g){ if (lwgeom_is_empty(g)) return LW_FAILURE; //将几何对象入栈 s-&gt;geoms = prepend_node(g, s-&gt;geoms); return LW_SUCCESS;}//迭代器向前一步，static int lwpointiterator_advance(LWPOINTITERATOR* s){ s-&gt;i += 1; //到达了当前点数组的末尾，需要从栈中弹出下一个点数组 if (s-&gt;pointarrays &amp;&amp; s-&gt;i &gt;= ((POINTARRAY*) s-&gt;pointarrays-&gt;item)-&gt;npoints) { s-&gt;pointarrays = pop_node(s-&gt;pointarrays); s-&gt;i = 0; } //当前点数组栈已经用消耗完了，需要从几何对象中提取出点数组来 if (!s-&gt;pointarrays) { LWGEOM* g; //如果几何对象栈顶是collection，那么就把它里面的几何对象 //都提出来重新入栈，确保当前栈顶是单独的几何对象 unroll_collections(s); //当前已经没有几何对象，并且也没有点数组了，即迭代器已经到末尾了 if (!s-&gt;geoms) { //返回失败 return LW_FAILURE; } //还可以提取点数组 s-&gt;i = 0; g = s-&gt;geoms-&gt;item; //从栈顶的几何对象中提取点数组 s-&gt;pointarrays = extract_pointarrays_from_lwgeom(g); //把栈顶出栈 s-&gt;geoms = pop_node(s-&gt;geoms); } //走到这里还是没有点数组，那就说明迭代器走到末尾了 if (!s-&gt;pointarrays) { return LW_FAILURE; } return LW_SUCCESS;}//从几何对象中提取点数组static LISTNODE* extract_pointarrays_from_lwgeom(LWGEOM* g){ //按照不同的几何类型，拿到它们底层的点数组。 //这里的prepend_node起到的作用只是创建一个新的链表。 switch(lwgeom_get_type(g)) { case POINTTYPE: return prepend_node(lwgeom_as_lwpoint(g)-&gt;point, NULL); case LINETYPE: return prepend_node(lwgeom_as_lwline(g)-&gt;points, NULL); ........ case POLYGONTYPE: { LISTNODE* n = NULL; LWPOLY* p = lwgeom_as_lwpoly(g); int i; for (i = p-&gt;nrings - 1; i &gt;= 0; i--) n = prepend_node(p-&gt;rings[i], n); return n; } .....} 12、边界框GBOXPostGIS为GBOX提供了许多操作的函数接口，大都挺简单的，这里只挑几个函数的代码贴一下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//再给一次GBOX的定义typedef struct{ lwflags_t flags; double xmin; double xmax; double ymin; double ymax; double zmin; double zmax; double mmin; double mmax;} GBOX;//创建并初始化GBOXGBOX* gbox_new(lwflags_t flags){ GBOX *g = (GBOX*)lwalloc(sizeof(GBOX)); gbox_init(g); g-&gt;flags = flags; return g;}void gbox_init(GBOX *gbox){ memset(gbox, 0, sizeof(GBOX));}//将GBOX（边界框）扩大void gbox_expand(GBOX *g, double d){ //所谓扩大，就是把每个维度的下边界下调，上边界上调 g-&gt;xmin -= d; g-&gt;xmax += d; g-&gt;ymin -= d; g-&gt;ymax += d; if (FLAGS_GET_Z(g-&gt;flags) || FLAGS_GET_GEODETIC(g-&gt;flags)) { g-&gt;zmin -= d; g-&gt;zmax += d; } if (FLAGS_GET_M(g-&gt;flags)) { g-&gt;mmin -= d; g-&gt;mmax += d; }}//合并两个GBOXint gbox_union(const GBOX *g1, const GBOX *g2, GBOX *gout){ //特判GBOX有为空的情况 if ( ( ! g1 ) &amp;&amp; ( ! g2 ) ) return LW_FALSE; else if (!g1) { memcpy(gout, g2, sizeof(GBOX)); return LW_TRUE; } else if (!g2) { memcpy(gout, g1, sizeof(GBOX)); return LW_TRUE; } //新的GBOX直接使用第一个的维度信息 gout-&gt;flags = g1-&gt;flags; //合并的原则是：GBOX每个坐标的范围取合并前两个GBOX的最值 gout-&gt;xmin = FP_MIN(g1-&gt;xmin, g2-&gt;xmin); gout-&gt;xmax = FP_MAX(g1-&gt;xmax, g2-&gt;xmax); gout-&gt;ymin = FP_MIN(g1-&gt;ymin, g2-&gt;ymin); gout-&gt;ymax = FP_MAX(g1-&gt;ymax, g2-&gt;ymax); gout-&gt;zmin = FP_MIN(g1-&gt;zmin, g2-&gt;zmin); gout-&gt;zmax = FP_MAX(g1-&gt;zmax, g2-&gt;zmax); return LW_TRUE;} 13、几何对象的通用序列化（2）这一节给出剩下的一些序列化的接口，和上一节序列化一样，不关心它的具体实现，只要知道在这里有这么个东西就好。 12345678910111213extern char* lwgeom_to_wkt(const LWGEOM *geom, uint8_t variant, int precision, size_t *size_out);extern uint8_t* lwgeom_to_wkb(const LWGEOM *geom, uint8_t variant, size_t *size_out);extern char* lwgeom_to_hexwkb(const LWGEOM *geom, uint8_t variant, size_t *size_out);extern char *lwgeom_to_ewkt(const LWGEOM *lwgeom);extern LWGEOM* lwgeom_from_wkb(const uint8_t *wkb, const size_t wkb_size, const char check);extern LWGEOM* lwgeom_from_wkt(const char *wkt, const char check);extern LWGEOM* lwgeom_from_hexwkb(const char *hexwkb, const char check);extern uint8_t* bytes_from_hexbytes(const char *hexbuf, size_t hexsize);extern char* hexbytes_from_bytes(const uint8_t *bytes, size_t size);extern LWGEOM* lwgeom_from_twkb(const uint8_t *twkb, size_t twkb_size, char check);extern uint8_t* lwgeom_to_twkb(const LWGEOM *geom, uint8_t variant, int8_t precision_xy, int8_t precision_z, int8_t precision_m, size_t *twkb_size);extern uint8_t* lwgeom_to_twkb_with_idlist(const LWGEOM *geom, int64_t *idlist, uint8_t variant, int8_t precision_xy, int8_t precision_z, int8_t precision_m, size_t *twkb_size); 另外对于WKT这种序列化类型，对于它的解析还提供了支持详细的解析结果的操作： 123extern int lwgeom_parse_wkt(LWGEOM_PARSER_RESULT *parser_result, char *wktstr, int parse_flags);void lwgeom_parser_result_init(LWGEOM_PARSER_RESULT *parser_result);void lwgeom_parser_result_free(LWGEOM_PARSER_RESULT *parser_result); 14、GEOS库的代理函数接口代理的意思是，一些几何运算是由GEOS库来实现的，在PostGIS的LWGEOM库提供的接口中，会先把lwgeom几何对象转换为GEOS库中的几何对象，再调用GEOS库的几何函数接口，再转换为lwgeom对象。 下面先列出LWGEOM库中的GEOS代理接口： 12345678910111213141516171819//liblwgeom.hconst char* lwgeom_geos_version(void);LWGEOM* lwgeom_geos_noop(const LWGEOM *geom) ;LWGEOM *lwgeom_normalize(const LWGEOM *geom);LWGEOM *lwgeom_intersection(const LWGEOM *geom1, const LWGEOM *geom2);LWGEOM *lwgeom_difference(const LWGEOM *geom1, const LWGEOM *geom2);LWGEOM *lwgeom_symdifference(const LWGEOM* geom1, const LWGEOM* geom2);LWGEOM *lwgeom_pointonsurface(const LWGEOM* geom);LWGEOM *lwgeom_centroid(const LWGEOM* geom);LWGEOM *lwgeom_union(const LWGEOM *geom1, const LWGEOM *geom2);LWGEOM *lwgeom_linemerge(const LWGEOM *geom1);LWGEOM *lwgeom_unaryunion(const LWGEOM *geom1);LWGEOM *lwgeom_clip_by_rect(const LWGEOM *geom1, double x0, double y0, double x1, double y1);LWCOLLECTION *lwgeom_subdivide(const LWGEOM *geom, uint32_t maxvertices);LWGEOM* lwgeom_snap(const LWGEOM* geom1, const LWGEOM* geom2, double tolerance);LWGEOM* lwgeom_sharedpaths(const LWGEOM* geom1, const LWGEOM* geom2);LWGEOM* lwgeom_offsetcurve(const LWGEOM *geom, double size, int quadsegs, int joinStyle, double mitreLimit);int lwgeom_is_simple(const LWGEOM *lwgeom); 我们以lwgeom_normalize为例看下内部实现是怎样的： 12345678910111213141516171819202122//lwgeom_geos.cLWGEOM* lwgeom_normalize(const LWGEOM* geom){ LWGEOM* result; int32_t srid = RESULT_SRID(geom); uint8_t is3d = FLAGS_GET_Z(geom-&gt;flags); //GEOSeometry是GEOS库提供的几何对象结构 GEOSGeometry* g; if (srid == SRID_INVALID) return NULL; //初始化GEOS库 initGEOS(lwnotice, lwgeom_geos_error); //将lwgeom对象转换为GEOS中的对象 if (!(g = LWGEOM2GEOS(geom, AUTOFIX))) GEOS_FAIL(); //调用GEOS中的函数接口，完成任务 if (GEOSNormalize(g) == -1) GEOS_FREE_AND_FAIL(g); GEOSSetSRID(g, srid); //再转换回lwgeom对象 if (!(result = GEOS2LWGEOM(g, is3d))) GEOS_FREE_AND_FAIL(g); //销毁GEOS对象，就好像所有工作都是由LWGEOM完成的 GEOSGeom_destroy(g); return result;} LWGEOM中关于GEOS的相关代码，基本上都是在lwgeom_geos.c中实现的，在lwgeom_geos.h中包含了geos_c.h，它是GEOS库提供的头文件。 另外还有一些依赖GEOS来实现某些功能的函数，它们也是在lwgeom_geos.c中实现的： 1234567LWGEOM* lwgeom_buildarea(const LWGEOM *geom) ;LWGEOM* lwgeom_make_valid(LWGEOM* geom);LWGEOM* lwgeom_split(const LWGEOM* lwgeom_in, const LWGEOM* blade_in);LWGEOM* lwgeom_node(const LWGEOM* lwgeom_in);LWGEOM* lwgeom_delaunay_triangulation(const LWGEOM *geom, double tolerance, int32_t edgeOnly);LWGEOM* lwgeom_voronoi_diagram(const LWGEOM* g, const GBOX* env, double tolerance, int output_edges);int * lwgeom_cluster_2d_kmeans(const LWGEOM **geoms, uint32_t ngeoms, uint32_t k); 15、依赖PROJ的额外函数有一些依赖PROJ库的函数： 123456789101112int lwgeom_transform_from_str(LWGEOM *geom, const char* instr, const char* outstr);#if POSTGIS_PROJ_VERSION &lt; 60projPJ projpj_from_string(const char* txt);#endifint lwgeom_transform(LWGEOM *geom, LWPROJ* pj);int ptarray_transform(POINTARRAY *pa, LWPROJ* pj);#if POSTGIS_PROJ_VERSION &gt;= 60LWPROJ *lwproj_from_PJ(PJ *pj, int8_t extra_geography_data);#endif 它们都需要PROJ4的支持，例如： 12345678910//lwgeom_transform.c//projPJ是PROJ提供的类型projPJ projpj_from_string(const char *str1){ if (!str1 || str1[0] == &apos;\\0&apos;) { return NULL; } //调用PROJ的接口 return pj_init_plus(str1);} 关于PROJ的内容，大部分都是在lwgeom_transform.c中实现的，在liblwgeom.h开头的位置，包含了PROJ的头文件，并且增加了LWGEOM中对应的类型： 123456789101112131415161718192021222324252627282930313233343536//低版本的PROJ#if POSTGIS_PROJ_VERSION &lt; 60#include &quot;proj_api.h&quot;typedef struct PJ{ projPJ pj_from; projPJ pj_to;} PJ;typedef PJ LWPROJ;#else//高版本的PROJ#include &quot;proj.h&quot;typedef struct LWPROJ{ PJ* pj; /* CRSs are swapped: Used in transformation calls */ uint8_t source_swapped; uint8_t target_swapped; /* Source crs is geographic: Used in geography calls (source srid == dst srid) */ uint8_t source_is_latlong; /* Source ellipsoid parameters */ double source_semi_major_metre; double source_semi_minor_metre;} LWPROJ;#endif#if POSTGIS_PROJ_VERSION &lt; 49/* Use the old (pre-2.2) geodesic functions */#undef PROJ_GEODESIC#else/* Enable new geodesic functions API */#define PROJ_GEODESIC#endif 到此为止，LWGEOM库的内容，我们就大致浏览一遍了。接下来可以进入PostGIS对外提供功能的部分了。","link":"/2020/06/05/read-postgis-code-2/"},{"title":"PostGIS源码-3-PostGIS导出函数之lwgeom_ogc.c","text":"从本篇文章开始看PostGIS为用户提供的功能是如何实现的。这里我们先只看postgis/目录下的代码。因为PostGIS导出的东西是函数、类型、操作符、之类的东西，并没有一个整体清晰的目录结构来让我们从根开始。也没有哪些函数或者是类型是比其他的更重要一些，让我们作为切入点。所以从哪里开始是一个问题。 在这里没什么好办法，对于导出函数，我选择每次挑一个.c文件，然后把它里面的内容选择感兴趣的看完。大致看完一遍之后，或许能领会到PostGIS的整体结构是如何组织的，到时候再来重新组织一下文章的顺序，也会有不少收益。 至于每次选择哪个.c文件，我是在postgis–3.0.1.sql中搜出以ST_*开头的函数有哪些（搜关键字：CREATE OR REPLACE FUNCTION ST_即可）。然后按照搜索得到列表，每次选择一个函数，再在PostGIS项目中找对对应的C语言实现，并且把这个实现所在的那个.c文件例的内容都看完。这样最后就能有章法的把所有源码都浏览一遍。 本篇文章看lwgeom_ogc.c中的内容。 1、读取/设置SRID123456789101112131415161718192021222324/* ST_SRID(geom geometry) :: int4 */PG_FUNCTION_INFO_V1(LWGEOM_get_srid);Datum LWGEOM_get_srid(PG_FUNCTION_ARGS){ //读取参数，几何对象是以gserialized格式存的 GSERIALIZED *geom=PG_GETARG_GSERIALIZED_P(0); //提取SRID int32_t srid = gserialized_get_srid(geom); //如果geom对象是我们拷贝出来的，则需要把它释放掉 PG_FREE_IF_COPY(geom,0); //返回结果 PG_RETURN_INT32(srid);}/* ST_SetSRID(geometry, int4) :: geometry */PG_FUNCTION_INFO_V1(LWGEOM_set_srid);Datum LWGEOM_set_srid(PG_FUNCTION_ARGS){ //读取参数，这里会把传入的几何对象参数进行一次拷贝，方便我们返回新的对象 GSERIALIZED *g = (GSERIALIZED *)PG_DETOAST_DATUM_COPY(PG_GETARG_DATUM(0)); //第二个参数是要设置的SRID int32_t srid = PG_GETARG_INT32(1); gserialized_set_srid(g, srid); //返回一个新的几何对象 PG_RETURN_POINTER(g);} 这是我们阅读的PostGIS的第一对函数，详细说一下。 首先，在这一系列的文章中，对于PostGIS导出的函数，在源码之前我会把该函数在sql脚本中声明的函数原型注释出来，方便对照。 其次，从上面的代码中可以看到，几何对象在PostGIS（或者说PostgreSQL）中是以GSERIALIZED的格式存储的。函数的传入和返回参数都是GSERIALIZED对象的指针。 这一节的两个函数分别是读取和设置几何对象的SRID，逻辑很简单，只是把传入的参数进行读取或者设置SRID，调用的gserialized_get_srid和gserialized_set_srid函数接口，我们在之前看LEGEOM库的源码时，已经看到过了。 2、获取几何对象类型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* GeometryType(geometry) :: text */PG_FUNCTION_INFO_V1(LWGEOM_getTYPE);Datum LWGEOM_getTYPE(PG_FUNCTION_ARGS){ GSERIALIZED *gser; text *text_ob; char *result; uint8_t type; static int maxtyplen = 20; //这里切片只返回了对象的头部结构体，因为我们只需要类型 gser = PG_GETARG_GSERIALIZED_P_SLICE(0, 0, gserialized_max_header_size()); //为返回结果申请空间，并且使用result来对text的数据域进行访问 text_ob = palloc0(VARHDRSZ + maxtyplen); result = VARDATA(text_ob); //读取几何对象的类型 type = gserialized_get_type(gser); if (type == POINTTYPE) strcpy(result,&quot;POINT&quot;); else if (type == MULTIPOINTTYPE) strcpy(result,&quot;MULTIPOINT&quot;); //省略中间的那些类型，节省篇幅.... else strcpy(result,&quot;UNKNOWN&quot;); //如果有M维的话，在加一个字符‘M’ if ( gserialized_has_m(gser) &amp;&amp; ! gserialized_has_z(gser) ) strcat(result, &quot;M&quot;); //设置返回text的长度 SET_VARSIZE(text_ob, strlen(result) + VARHDRSZ); /* size of string */ PG_FREE_IF_COPY(gser, 0); PG_RETURN_TEXT_P(text_ob);}//static char *stTypeName[] = {&quot;Unknown&quot;, &quot;ST_Point&quot;, &quot;ST_LineString&quot;, //略去后续/* ST_GeometryType(geometry) :: TEXT*/PG_FUNCTION_INFO_V1(geometry_geometrytype);Datum geometry_geometrytype(PG_FUNCTION_ARGS){ GSERIALIZED *gser; text *type_text; //只读出GSERIALIZED结构的头部 gser = PG_GETARG_GSERIALIZED_P_SLICE(0, 0, gserialized_max_header_size()); //获取对应的类型，然后转换乘text type_text = cstring_to_text(stTypeName[gserialized_get_type(gser)]); PG_FREE_IF_COPY(gser, 0); PG_RETURN_TEXT_P(type_text);} 这两个都是获取几何对象类型的函数。两者略有不同，前者返回的是POINT，后者是ST_Point这样。但是前者在sql脚本中已经被标记为要废弃了。 3、获取几何对象中的元素个数这里有两个函数，一个是查线串中点的个数，另一个是查容器中直接子元素的个数。 123456789101112131415161718192021/* ST_NumPoints(geometry) :: int4 */PG_FUNCTION_INFO_V1(LWGEOM_numpoints_linestring);Datum LWGEOM_numpoints_linestring(PG_FUNCTION_ARGS){ GSERIALIZED *geom = PG_GETARG_GSERIALIZED_P(0); //反序列化 LWGEOM *lwgeom = lwgeom_from_gserialized(geom); int count = -1; int type = lwgeom-&gt;type; //只有这几种类型才去数它里面有多少个点 if ( type == LINETYPE || type == CIRCSTRINGTYPE || type == COMPOUNDTYPE ) count = lwgeom_count_vertices(lwgeom); //清理额外申请的内存 lwgeom_free(lwgeom); PG_FREE_IF_COPY(geom, 0); //返回结果 if ( count &lt; 0 ) PG_RETURN_NULL(); PG_RETURN_INT32(count);} 注：在之后的代码中把声明调用约定版本一那句话去掉了，白占篇幅。 12345678910111213141516171819202122/* ST_NumGeometries(geometry) :: int4 */Datum LWGEOM_numgeometries_collection(PG_FUNCTION_ARGS){ GSERIALIZED *geom = PG_GETARG_GSERIALIZED_P(0); LWGEOM *lwgeom; int32 ret = 1; //反序列化 lwgeom = lwgeom_from_gserialized(geom); if ( lwgeom_is_empty(lwgeom) ) //空容器 { ret = 0; } else if ( lwgeom_is_collection(lwgeom) ) { //这里只计算了直接子对象的个数 LWCOLLECTION *col = lwgeom_as_lwcollection(lwgeom); ret = col-&gt;ngeoms; } //清理空间并返回。 lwgeom_free(lwgeom); PG_FREE_IF_COPY(geom, 0); PG_RETURN_INT32(ret);} 4、获取容器中的第n个几何对象1234567891011121314151617181920212223242526272829303132333435363738/* ST_GeometryN(geometry,integer) :: geometry */Datum LWGEOM_geometryn_collection(PG_FUNCTION_ARGS){ GSERIALIZED *geom = PG_GETARG_GSERIALIZED_P(0); GSERIALIZED *result; int type = gserialized_get_type(geom); int32 idx; LWCOLLECTION *coll; LWGEOM *subgeom; //传入的下标参数，是从1开始的 idx = PG_GETARG_INT32(1); idx -= 1; //传入的几何对象本身就是非容器对象 if (type==POINTTYPE || type==LINETYPE || type==CIRCSTRINGTYPE || type==COMPOUNDTYPE || type==POLYGONTYPE || type==CURVEPOLYTYPE || type==TRIANGLETYPE) { //如果正好索引的元素就是第1个，那么返回当前对象就可以了 if ( idx == 0 ) PG_RETURN_POINTER(geom); //否则调用参数不合法，直接返回NULL PG_RETURN_NULL(); } //反序列化，并把lwgeom转换为collection coll = lwgeom_as_lwcollection(lwgeom_from_gserialized(geom)); //索引下标不合法 if ( idx &lt; 0 ) PG_RETURN_NULL(); if ( idx &gt;= (int32) coll-&gt;ngeoms ) PG_RETURN_NULL(); //索引对应的几何对象 subgeom = coll-&gt;geoms[idx]; subgeom-&gt;srid = coll-&gt;srid; //添加边界框 if ( coll-&gt;bbox ) lwgeom_add_bbox(subgeom); //序列化对象，清理内存并返回 result = geometry_serialize(subgeom); lwcollection_free(coll); PG_FREE_IF_COPY(geom, 0); PG_RETURN_POINTER(result);} 这个函数是获取容器中的第n个几何对象，注意在调用时下标是1开始的。其他没什么值得说的，看注释好了。 5、获取几何对象的维度123456789/* ST_Dimension(geometry) :: int4 */Datum LWGEOM_dimension(PG_FUNCTION_ARGS){ GSERIALIZED *geom = PG_GETARG_GSERIALIZED_P(0); LWGEOM *lwgeom = lwgeom_from_gserialized(geom); int dimension = -1; //调用LWGEOM库的接口计算维度 dimension = lwgeom_dimension(lwgeom); //后面代码就是清理内存返回结果，节省篇幅了。} 这个导出函数的关键在于lwgeom_dimension的实现，因为这个是在LWGEOM库中实现的，而且规则也很简单，所以只说下规则，不贴它的代码了。 这里说的维度，并不是指坐标是2D、3D那种。具体的规则是：点=0，线=1，多边形=2，曲面=3。对于容器来说，返回的是容器中维度最大的那个几何对象的维度。 6、获取多边形的环这一节有两个导出函数：获取外环和第n个内环。依次来看看。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* ST_ExteriorRing(geometry) :: geometry */Datum LWGEOM_exteriorring_polygon(PG_FUNCTION_ARGS){ //定义变量获取参数省略 //找环只对多边形类型的几何对象有意义 if ( (type != POLYGONTYPE) &amp;&amp; (type != CURVEPOLYTYPE) &amp;&amp; (type != TRIANGLETYPE)) { PG_RETURN_NULL(); } lwgeom = lwgeom_from_gserialized(geom); if( lwgeom_is_empty(lwgeom) ) //空对象，也创建一个空线串返回 { line = lwline_construct_empty(lwgeom-&gt;srid, lwgeom_has_z(lwgeom), lwgeom_has_m(lwgeom)); result = geometry_serialize(lwline_as_lwgeom(line)); } else if ( type == POLYGONTYPE ) { LWPOLY *poly = lwgeom_as_lwpoly(lwgeom); //多边形对象的第一个环就是外环 extring = poly-&gt;rings[0]; //该多边形的边界框，其实就是由最外面的环计算得出的 if ( poly-&gt;bbox ) bbox = gbox_copy(poly-&gt;bbox); //创建一个线串返回 line = lwline_construct(poly-&gt;srid, bbox, extring); result = geometry_serialize((LWGEOM *)line); lwgeom_release((LWGEOM *)line); } else if ( type == TRIANGLETYPE ) { LWTRIANGLE *triangle = lwgeom_as_lwtriangle(lwgeom); //三角形，它自己就是外环 if ( triangle-&gt;bbox ) bbox = gbox_copy(triangle-&gt;bbox); line = lwline_construct(triangle-&gt;srid, bbox, triangle-&gt;points); result = geometry_serialize((LWGEOM *)line); lwgeom_release((LWGEOM *)line); } else { //曲线多边形直接返回外环 LWCURVEPOLY *curvepoly = lwgeom_as_lwcurvepoly(lwgeom); result = geometry_serialize(curvepoly-&gt;rings[0]); } lwgeom_free(lwgeom); PG_FREE_IF_COPY(geom, 0); PG_RETURN_POINTER(result);} 这里可以得到的一个信息是：多边形的第一个环就是它最外层的环。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* ST_InteriorRingN(geometry,integer) :: geometry */Datum LWGEOM_interiorringn_polygon(PG_FUNCTION_ARGS){ //变量定义和参数获取省略 //只有多边形和曲线多边形支持获取第n个环这种操作 if ( (type != POLYGONTYPE) &amp;&amp; (type != CURVEPOLYTYPE) ) { PG_FREE_IF_COPY(geom, 0); PG_RETURN_NULL(); } //保证几何对象非空 lwgeom = lwgeom_from_gserialized(geom); if( lwgeom_is_empty(lwgeom) ) { lwpoly_free(poly); PG_FREE_IF_COPY(geom, 0); PG_RETURN_NULL(); } if ( type == POLYGONTYPE) { poly = lwgeom_as_lwpoly(lwgeom_from_gserialized(geom)); //保证索引的下标合法 if ( wanted_index &gt;= (int32)poly-&gt;nrings ) { lwpoly_free(poly); PG_FREE_IF_COPY(geom, 0); PG_RETURN_NULL(); } //索引指定的环 ring = poly-&gt;rings[wanted_index]; //这里计算边界框，用的是指定内环来算的 if ( poly-&gt;bbox ) { bbox = lwalloc(sizeof(GBOX)); ptarray_calculate_gbox_cartesian(ring, bbox); } //构造结果并返回 line = lwline_construct(poly-&gt;srid, bbox, ring); result = geometry_serialize((LWGEOM *)line); lwline_release(line); lwpoly_free(poly); } else { //曲线多边形的与普通多边形区别不大，只是没有计算边界框 curvepoly = lwgeom_as_lwcurvepoly(lwgeom_from_gserialized(geom)); if (wanted_index &gt;= (int32)curvepoly-&gt;nrings) { PG_FREE_IF_COPY(geom, 0); lwgeom_release((LWGEOM *)curvepoly); PG_RETURN_NULL(); } result = geometry_serialize(curvepoly-&gt;rings[wanted_index]); lwgeom_free((LWGEOM*)curvepoly); } PG_FREE_IF_COPY(geom, 0); PG_RETURN_POINTER(result);} 这里源代码中注释的是获取第n个内环。但是从实现上看，我觉得倒不如说是获取第n个环。 后面还有一个获取线串中第n个点的函数，逻辑挺简单直白的，所以我只贴出它的声明了： 12/* ---- ST_PointN(geometry, integer) :: geometry */Datum LWGEOM_pointn_linestring(PG_FUNCTION_ARGS); 7、获取点下标这一系列函数有四个，分别是获取几何对象第一个点的XYZM的下标。把这四个函数的声明贴出来，实现只拿X坐标举例看下好了： 1234567891011121314151617181920212223/* ---- ST_X(geometry) :: float8 */Datum LWGEOM_x_point(PG_FUNCTION_ARGS);/* ---- ST_Y(geometry) :: float8 */Datum LWGEOM_y_point(PG_FUNCTION_ARGS);/* ---- ST_Z(geometry) :: float8 */Datum LWGEOM_z_point(PG_FUNCTION_ARGS);/* ---- ST_M(geometry) :: float8 */Datum LWGEOM_m_point(PG_FUNCTION_ARGS);Datum LWGEOM_x_point(PG_FUNCTION_ARGS){ GSERIALIZED *geom = PG_GETARG_GSERIALIZED_P(0); POINT4D pt; //确定是必须包含点的类型 if (gserialized_get_type(geom) != POINTTYPE) lwpgerror(&quot;Argument to ST_X() must have type POINT&quot;); //读取第一个点 if (gserialized_peek_first_point(geom, &amp;pt) == LW_FAILURE) { PG_RETURN_NULL(); } //直接用结构体的 . 访问符访问x坐标 PG_RETURN_FLOAT8(pt.x);} 8、获取线串的起止点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* ST_StartPoint(geometry) :: geometry */Datum LWGEOM_startpoint_linestring(PG_FUNCTION_ARGS){ GSERIALIZED *geom = PG_GETARG_GSERIALIZED_P(0); LWGEOM *lwgeom = lwgeom_from_gserialized(geom); LWPOINT *lwpoint = NULL; int type = lwgeom-&gt;type; //确保是线串类型 if ( type == LINETYPE || type == CIRCSTRINGTYPE ) { //获取第0个，也就是第一个点 lwpoint = lwline_get_lwpoint((LWLINE*)lwgeom, 0); } else if ( type == COMPOUNDTYPE ) { //复合类型，要从它的子类型找中到第一个点的 lwpoint = lwcompound_get_startpoint((LWCOMPOUND*)lwgeom); } //清理并返回 lwgeom_free(lwgeom); PG_FREE_IF_COPY(geom, 0); if ( ! lwpoint ) PG_RETURN_NULL(); PG_RETURN_POINTER(geometry_serialize(lwpoint_as_lwgeom(lwpoint)));}//找到几何对象中的第一个线串的最后一个点/* ST_EndPoint(geometry) :: geometry */Datum LWGEOM_endpoint_linestring(PG_FUNCTION_ARGS){ GSERIALIZED *geom = PG_GETARG_GSERIALIZED_P(0); LWGEOM *lwgeom = lwgeom_from_gserialized(geom); LWPOINT *lwpoint = NULL; int type = lwgeom-&gt;type; if ( type == LINETYPE || type == CIRCSTRINGTYPE ) { //线串类型，直接索引最后一个点 LWLINE *line = (LWLINE*)lwgeom; if ( line-&gt;points ) lwpoint = lwline_get_lwpoint((LWLINE*)lwgeom, line-&gt;points-&gt;npoints - 1); } else if ( type == COMPOUNDTYPE ) { //复合类型，找到第一个线串的最后一个点 lwpoint = lwcompound_get_endpoint((LWCOMPOUND*)lwgeom); } //清理并返回 lwgeom_free(lwgeom); PG_FREE_IF_COPY(geom, 0); if ( ! lwpoint ) PG_RETURN_NULL(); PG_RETURN_POINTER(geometry_serialize(lwpoint_as_lwgeom(lwpoint)));} 9、几何对象的文本形式将几何对象转换为文本形式或从文本形式转换为几何对象，这里的文本形式是WKT并返回。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* ST_AsText(geometry) :: TEXT *//* ST_AsText(geometry, int4) :: TEXT */Datum LWGEOM_asText(PG_FUNCTION_ARGS){ GSERIALIZED *geom; LWGEOM *lwgeom; char *wkt; size_t wkt_size; text *result; //double精度，即double小数点后的位数 int dbl_dig_for_wkt = DBL_DIG; //获取几何对象 geom = PG_GETARG_GSERIALIZED_P(0); lwgeom = lwgeom_from_gserialized(geom); //根据参数个数不同，有两种调用方式 if (PG_NARGS() &gt; 1) dbl_dig_for_wkt = PG_GETARG_INT32(1); //调用LWGEOM库的转换函数 wkt = lwgeom_to_wkt(lwgeom, WKT_ISO, dbl_dig_for_wkt, &amp;wkt_size); lwgeom_free(lwgeom); //将C字符串转换为PgSQL的TEXT，返回结果 result = cstring_to_text(wkt); lwfree(wkt); PG_FREE_IF_COPY(geom, 0); PG_RETURN_TEXT_P(result);}/* ST_GeometryFromText(text) :: geometry *//* ST_GeometryFromText(text, int4) :: geometry */Datum LWGEOM_from_text(PG_FUNCTION_ARGS){ text *wkttext = PG_GETARG_TEXT_P(0); char *wkt = text_to_cstring(wkttext); LWGEOM_PARSER_RESULT lwg_parser_result; GSERIALIZED *geom_result = NULL; LWGEOM *lwgeom; //调用解析接口，这里调用的是可以返回详细解析结果的那种 if (lwgeom_parse_wkt(&amp;lwg_parser_result, wkt, LW_PARSER_CHECK_ALL) == LW_FAILURE ) PG_PARSER_ERROR(lwg_parser_result); lwgeom = lwg_parser_result.geom; //WKT格式默认不带SRID，所以SRID应该是SRID_UNKNOWN。EWKT是带SRID的 if ( lwgeom-&gt;srid != SRID_UNKNOWN ) { elog(WARNING, &quot;OGC WKT expected, EWKT provided - use GeomFromEWKT() for this&quot;); } //这个函数也支持第二个可选参数，不过不是上一个函数中的精度，而是可以指定SRID if ( PG_NARGS() &gt; 1 ) lwgeom_set_srid(lwgeom, PG_GETARG_INT32(1)); //返回结果 geom_result = geometry_serialize(lwgeom); lwgeom_parser_result_free(&amp;lwg_parser_result); PG_RETURN_POINTER(geom_result);} 这是我们第一次见到一个导出函数，有两种调用方式的。注意两个函数的第二个参数的意义并不相同。 注：如果想知道几何对象与WKT的转换规则，去看LWGEOM中的实现。 10、几何对象的二进制形式这里的二进制形式是WKB。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* ST_AsBinary(geography) :: bytea *//* ST_AsBinary(geography, text) :: bytea */Datum LWGEOM_asBinary(PG_FUNCTION_ARGS){ //参数定义略 //获取第一个参数，几何对象 geom = PG_GETARG_GSERIALIZED_P(0); lwgeom = lwgeom_from_gserialized(geom); //可选的第二个参数是，用户指定的字节序 if ( (PG_NARGS()&gt;1) &amp;&amp; (!PG_ARGISNULL(1)) ) { text *wkb_endian = PG_GETARG_TEXT_P(1); //使用用户指定的字节序，XDR好像是一种与体系结构无关的表示数据的方式 if ( ! strncmp(VARDATA(wkb_endian), &quot;xdr&quot;, 3) || ! strncmp(VARDATA(wkb_endian), &quot;XDR&quot;, 3) ) { variant = variant | WKB_XDR; } else { variant = variant | WKB_NDR; } } //调用LWGEOM接口进行转换 wkb = lwgeom_to_wkb(lwgeom, variant, &amp;wkb_size); lwgeom_free(lwgeom); //返回以可边长类型返回结果 result = palloc(wkb_size + VARHDRSZ); memcpy(VARDATA(result), wkb, wkb_size); SET_VARSIZE(result, wkb_size + VARHDRSZ); lwfree(wkb); /* Return the text */ PG_FREE_IF_COPY(geom, 0); PG_RETURN_BYTEA_P(result);}/* ST_GeomFromWKB(bytea) :: geometry *//* ST_GeomFromWKB(bytea, int) :: geometry *//* ST_WKBToSQL(WKB bytea) :: geometry */Datum LWGEOM_from_WKB(PG_FUNCTION_ARGS){ bytea *bytea_wkb = PG_GETARG_BYTEA_P(0); int32 srid = 0; GSERIALIZED *geom; LWGEOM *lwgeom; //直接从WKB字节流转换为lwgeom uint8_t *wkb = (uint8_t*)VARDATA(bytea_wkb); lwgeom = lwgeom_from_wkb(wkb, VARSIZE_ANY_EXHDR(bytea_wkb), LW_PARSER_CHECK_ALL); //添加边界框 if ( lwgeom_needs_bbox(lwgeom) ) lwgeom_add_bbox(lwgeom); //之后就是序列化+返回了 geom = geometry_serialize(lwgeom); lwgeom_free(lwgeom); PG_FREE_IF_COPY(bytea_wkb, 0); //WKB默认是不带SRID的，EWKB带SRID if ( gserialized_get_srid(geom) != SRID_UNKNOWN ) { elog(WARNING, &quot;OGC WKB expected, EWKB provided - use GeometryFromEWKB() for this&quot;); } //可选的第二个参数是用来设置SRID的 if ( PG_NARGS() &gt; 1 ) { srid = PG_GETARG_INT32(1); if ( srid != gserialized_get_srid(geom) ) gserialized_set_srid(geom, srid); } PG_RETURN_POINTER(geom);} 同样，这两个函数的核心部分还是调用的LWGEOM库进行WKB二进制格式的转换。感兴趣的话可以去LWGEOM库看下如何实现的。 11、判断线串是否闭合12/* ST_IsClosed(geometry) :: boolean */Datum LWGEOM_isclosed(PG_FUNCTION_ARGS); 这个导出函数的实现过于简单，就是转而调用LWGEOM的接口，所以不贴实现了。倒是可以说下判断闭合的规则： 如果几何对象是线串，则判断起点是否和终点相同。 如果几何对象是只包含线串的容器，则判断是否每个线串都闭合 否则返回FALSE lwgeom_ogc.c的内容已经全部看完了。尽管这是我看的PostGIS业务代码中的第一个.c文件，但是我有一种强烈的感觉： 业务代码大部分都是依靠调用LWGEOM库提供的接口，PostGIS真正精华的部分还是LWGEOM库。 以上就是本篇的所有内容了。","link":"/2020/06/25/read-postgis-code-3/"}],"tags":[],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"PostGIS","slug":"PostGIS","link":"/categories/PostGIS/"},{"name":"codeforces","slug":"codeforces","link":"/categories/codeforces/"},{"name":"PostGIS In Action","slug":"PostGIS/PostGIS-In-Action","link":"/categories/PostGIS/PostGIS-In-Action/"},{"name":"PostGIS源码","slug":"PostGIS/PostGIS源码","link":"/categories/PostGIS/PostGIS%E6%BA%90%E7%A0%81/"},{"name":"PostgreSQL","slug":"PostgreSQL","link":"/categories/PostgreSQL/"}]}