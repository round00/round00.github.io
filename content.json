{"pages":[],"posts":[{"title":"黎明","text":"终于搭好自己的博客了。之前的工作和学习过程中多多少少也记录了一些东西，但是没有系统的整理，文档东放一个西放一个。从现在开始要养成一个系统的、总结记录的好习惯。 FLAG立个Flag： 每周至少一场Codeforces或者Topcoder，并且在完成后写总结。 每周至少一篇关于学到的新东西的记录。 坚持记录总结工作中遇到的比较通用的问题。 这样也能锻炼一下自己的文字能力，同时也给自己一点压力，逐渐养成一个良好的习惯。","link":"/2020/05/12/Beginning/"},{"title":"Chapter3 组织空间数据","text":"本章会介绍你可以设计的表布局来存储空间数据。然后给出一个对真实世界中城市建模的例子。最后讨论使用规则和触发器来管理表和视图的插入和更新。 一、空间存储方法在数据库设计时有很多需要考虑的因素，例如：所需要支持的分析特性、查询的速度、等等。对于空间数据库，在设计过程中还有一些附加的考虑因素： 数据的可用性 存储数据的精度 需要兼容什么地图工具 不像在普通数据库中，如果设计差一点的话，可能就是查询慢一点。在空间数据库中，如果设计的不好，可能一个查询在你这辈子都跑不完。最开始数据库设计的越好，之后就越少绕弯路。 在本节中会介绍三种通用的空间数据库中组织数据的方式： 异构几何类型列 同构几何类型列 表继承 接下来会介绍如何使用它们，以及各自的优劣势。 1、异构几何类型列这种方式不用考虑约束列为某种特定的几何类型。其实应该就是上一章中所说的geometrycollections。但是使用这种通用的几何列，并不意味着没有任何附加约束。仍然应该审慎地保证数据是完好的。建议强制使得空间参考系和空间维度一致。 使用这种方法的优点： 允许你对感兴趣的特征执行一个单独的查询，而不用放弃使用最合适的几何类型对它们进行建模。 简单。可以把非空间属性相同或不同所有的几何对象放到一个表中。 创建一个表很快，可以直接在创建表语句中指定几何列，而不用再调用AddGeo…函数。在你需要迭代的从非常多的表中加载数据并且你不知道它们包含的几何类型是怎么样的时候，尤为方便。 缺点： 存在可能将不合适的几何类型加入到一个对象中的风险。如果没有空间参考系或者维度的约束，之后的查询可能会出错。 许多第三方工具不能处理这种列。 在一些场景下，你只需要导出某种类型的几何对象，此时只能不断的对几何类型进行过滤。在表很大的情况下，这种行为会很慢，并且需要不断重复的去做。 把所有的几何数据丢到一个表里，可能会导致许多笨拙的自连接。例如一个表里既存放兴趣点，也存放多边形。当需要验证点是否在多边形中时，就需要将这个表和自己连接，然后再一次判断。如果点的个数是n，多边形的个数是m，那就是自连接的个数就是（n+m）（n+m）。而如果分开两个表来存放，那么连接的个数就是n\\m。 2、同构几何类型列这种方法避免了在同一个几何列中存在不同的几何对象。对一个城市建模时，可能有如下的方案： 把所有几何对象放在一个表中，这个表有四列：名称、点、线串、多边形。 把所有几何对象放在不同的表中，有三个表：名称+点、名称+线串、名称+多边形。 接下来也看看这种方法的优缺点： 优点： 强制保证了一致性，避免了无心的几何类型混合。 第三方工具依赖于几何对象的一致性。 在表连接的时候，会有更好的性能。 在需要画不同类型的几何对象时，将不同的几何对象放到不同的表中效率会更高。 在处理巨大的数据集的时候，分表可以使得让你享受将数据分别放在不同的物理磁盘上的好处。 PostgreSQL的表空间：它是一个物理的文件夹位置，而schema是上逻辑的。默认情况下，创建的所有表都会放到同一个表空间里。随着表大小的不断增加，可以创建额外的表空间，使你的表们分布在不同的表空间，即分布在不同的磁盘上，从而能使得磁盘的IO速率最大化。 缺点： 当你需要查询多种类型的几何对象时，你必须重新排序到一个合并的查询中。这样会增加查询的复杂度、降低速度。 如果你在一个表中放多个几何列，会有性能问题。这样会使表中的行更加臃肿，从而会使查询更慢，在select和update时都是这样。 3、表继承表继承是目前为止最多功能的一种方法，但是也更加复杂一点。pgsql的一个独一无二的功能是提供了表继承。可以利用这一特性，来获得前面两种方法的优点。表继承的意思是一个表可以继承父表的结构。父表不需要存储任何数据，而是将数据存储到子表当中。在这种情况下，父表常常被看做是抽象表，类似于面向对象的抽象类。子表继承父表的所有列，并且子表可以由自己的列。这些列只有当直接查询子表的时候才会展示出来。检查约束会被继承。主键和外键约束不会被继承。PostgreSQL支持多继承，子表可以继承多个父表，并且也不会限制继承的层数。 为了实现表继承这种存储方式，可以创建一个抽象表来根据非几何属性组织数据。然后创建子表来约束几何类型。在这种模式下可以查询父表然后看到所有子表的数据。或者当只需要某个几何类型时只查询某个子表。例如，创建一个父表来组织多种多样的几何类型，创建子表来存储某一种类型的几何对象。这样当我们不关心几何类型时，就从父表查询，否则从子表查询。目前为止，只有PostgreSQL支持这种优雅的方法。 约束排除：PostgreSQL有一个配置选项叫做约束排除，经常和表继承结合使用。当开启了这个选项的时候，查询会检查表约束然后决定在查询中是否跳过这个表。 使用这种方式的优缺点： 优点： 你可以查询一个有继承结构的表就好像它是一个表一样。或者在有需要时分开查询。 如果按照几何类型分割，可以根据需要查询某一特定的几何类型或者查询所有几何类型。 使用约束排除，查询可以聪明的跳过那些没有一行能满足过滤条件的表。 继承可以随时设置或者取消，使得执行数据加载更加方便。 很多第三方工具可以把父表看做是一个拥有完好的域的表，即使这个表中没有任何和几何相关的列。并且表继承和一些第三方工具，例如OpenJUMP、GeoServer等可以很好的合作。 缺点： 表继承不被其他一些主要的数据库所支持。如果想切换到其他数据库，你之前的代码可能会有问题。 主键和外键约束不会传递到子表。 为了维护继承关系，在添加数据的时候需要额外的操作来保证数据被恰当的添加到了父表或者某个子表中。在表更新的时候，你可能想当然的认为一个子表中的记录会自动的移动到另一个表中，但是这种情况会造成检查冲突。这意味着必须创建规则或者触发器。 是否应该完全使用约束排除来跳过一个表。在第一次执行查询的时候，会有性能问题。 注意继承结构中表的总数量，当有几百张表的时候，性能会显著下降。 接下来给出一个例子，来展示如何使用表继承建模。 12345678910111213141516171819202122-- 创建父表CREATE TABLE roads( gid serial PRIMARY KEY, road_name character varying(100));-- 为父表添加一个几何列SELECT AddGeometryColumn(&apos;public&apos;, &apos;roads&apos;, &apos;geom&apos;, 4269, &apos;LINESTRING&apos;,2);-- 创建子表CREATE TABLE roads_NE( CONSTRAINT pk PRIMARY KEY(gid)) INHERITS(roads);-- 给子表添加约束，使得该子表中的内容都是在指定范围内的ALTER TABLE roads_NE ADD CONSTRAINT chk CHECK( state IN (&apos;MA&apos;, &apos;ME&apos;, &apos;NH&apos;, &apos;VT&apos;, &apos;CT&apos;, &apos;RI&apos;) );CREATE TABLE roads_SW( CONSTRAINT pk PRIMARY KEY (gid)) INHERITS (roads);ALTER TABLE roads_SW ADD CONSTRAINT chk CHECK ( state IN (&apos;AZ&apos;, &apos;NM&apos;, &apos;NV&apos;) );-- 一个简单的查询，由于上面约束的存在，只会查询roads_NE子表，另外一个子表被过滤了SELECT gid, road_name, geom FROM roads WHERE state = &apos;MA&apos;; 以上就介绍完了三种空间存储方法。 二、对一个真实的城市建模在本节，以巴黎为例对一个城市建模，使用我们之前介绍的方法。这个城市被分为20个行政区划，如下图所示。 我们把每个区域建模为一个多边形容器，并且把它们插入到一个arrondissements表中。 在书上并没有看到加载数据的具体方法，不过在数据文件中介绍了一下，下面给出加载数据的过程。 首先，加载ch03.arrondissements表： 12-- 先创建一个临时schemaCREATE SCHEMA staging; 1234#先用shp2pgsql把数据加载到staging.paris_arrondissements表中。shp2pgsql -s 4326 /tmp/postgis/ch03/paris_-_arrondissements.shp staging.paris_arrondissements | psql -h localhost -U postgres -p 4096 test#在执行load.sql脚本把对数据进行转换psql -d test -U postgres -p 4096 -f /tmp/postgis/ch03/loading.sql 然后，使用psql加载planet_osm_line.sql、planet_osm_point.sql和planet_osm_polygon.sql 脚本： 1psql -d test -U postgres -p 4096 -f /tmp/postgis/ch03/planet_osm_line.sql 1psql -d test -U postgres -p 4096 -f /tmp/postgis/ch03/planet_osm_point.sql 1psql -d test -U postgres -p 4096 -f /tmp/postgis/ch03/planet_osm_polygon.sql 这里会把osm数据加载到public schema中，而不是ch03。本来我想修改一下sql脚本直接加载到ch03中，但是我看书上后续的代码都是基于osm数据在public schema中的，所有就这样吧。 1、使用异构几何列建模如果我们主要是按照区域来查找，而不考虑其中的几何类型的话，使用这种建模方式是最方便的。接下来创建表： 12345678910CREATE TABLE ch03.paris_hetero( gid serial NOT NULL, osm_id integer, geom geometry, ar_num integer, tags hstore, CONSTRAINT paris_hetero_pk PRIMARY KEY(gid), CONSTRAINT enforce_dims_geom CHECK (ST_NDims(geom) = 2), CONSTRAINT enforce_srid_geom CHECK (ST_SRID(geom) = 32631)); 在执行这份SQL代码的时候，提示了hstore没有安装。在网上搜索了一下，其实在PostgreSQL的源码中是有hstore的源码的，进入PostgreSQL源码/contrib/hstore目录下执行 make &amp;&amp; make install后，再在psql或者pgAdmin中执行create extension hstore;就可以了。 ar_num保存区域代号。hstore是用来存储键值对的数据类型。也可以使用GIST进行索引。在这里我们增加了两个约束：几何维度为2，SRID为32631。 ar_num这个属性并没有被OSM数据维护，但是可以通过对OSM数据和区域表求交来计算出这个属性。下面的代码展示了这个操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243INSERT INTO ch03.paris_hetero(osm_id, geom, ar_num, tags) SELECT o.osm_id, ST_Intersection(o.geom, a.geom) AS geom, a.ar_num, o.tags FROM (SELECT osm_id, ST_Transform(way, 32631) AS geom, tags FROM planet_osm_line) AS o INNER JOIN ch03.arrondissements AS a ON ST_Intersects(o.geom, a.geom);INSERT INTO ch03.paris_hetero(osm_id, geom, ar_num, tags) SELECT o.osm_id, ST_Intersection(o.geom, a.geom) AS geom, a.ar_num, o.tags FROM (SELECT osm_id, ST_Transform(way, 32631) AS geom, tags FROM planet_osm_polygon) AS o INNER JOIN ch03.arrondissements AS a ON ST_Intersects(o.geom, a.geom);INSERT INTO ch03.paris_hetero(osm_id, geom, ar_num, tags) SELECT o.osm_id, o.geom, a.ar_num, o.tags FROM (SELECT osm_id, ST_Transform(way, 32631) AS geom, tags FROM planet_osm_point) AS o INNER JOIN ch03.arrondissements AS a ON ST_Intersects(o.geom, a.geom);-- 创建索引CREATE INDEX idx_paris_hetero_geom ON ch03.paris_hetero USING gist(geom);CREATE INDEX idx_paris_hetero_tags ON ch03.paris_hetero USING gist(tags);-- 更新统计数据VACUUM ANALYZE ch03.paris_hetero; 这样在同一个表的一列中就放入了多种几何类型。下面这份代码，查询同一个区域中不同的特征地点的个数： 123SELECT ar_num, COUNT(DISTINCT osm_id) AS compte FROM ch03.paris_heteroGROUP BY ar_num; 下面是这个例子中的几个hstore数据的样子： 12345&quot;name&quot;=&gt;&quot;RER A&quot;, &quot;layer&quot;=&gt;&quot;-6&quot;, &quot;tunnel&quot;=&gt;&quot;yes&quot;, &quot;railway&quot;=&gt;&quot;rail&quot;, &quot;z_order&quot;=&gt;&quot;-65&quot;, &quot;operator&quot;=&gt;&quot;RATP&quot;&quot;ref&quot;=&gt;&quot;FR-RER A&quot;, &quot;route&quot;=&gt;&quot;light_rail&quot;, &quot;z_order&quot;=&gt;&quot;0&quot;, &quot;operator&quot;=&gt;&quot;RATP&quot;, &quot;route_name&quot;=&gt;&quot;Boissy-St-Léger--Saint-Germain-en-Laye&quot;, &quot;description&quot;=&gt;&quot;RER A A2-&gt;A1&quot;, &quot;route_pref_color&quot;=&gt;&quot;0&quot;&quot;name&quot;=&gt;&quot;Rue Copernic&quot;, &quot;oneway&quot;=&gt;&quot;yes&quot;, &quot;highway&quot;=&gt;&quot;residential&quot;, &quot;z_order&quot;=&gt;&quot;3&quot; 使用hstore类型的主要好处是，你不用为杂项属性操心，不用为它们创建一些很不常用的列。但是缺点也很明显，你无法像查询字符串或者数值列那样进行简单的查询。 注意：hstore是PostgreSQL的一个数据类型。 关于上面所说的缺点的一个简单的克服办法是：创建一个视图，来讲hstore属性映射到虚拟的属性列中。下面是创建这样视图的例子： 123456CREATE OR REPLACE VIEW ch03.vw_paris_points ASSELECT gid, osm_id, ar_num, geom, tags-&gt;&apos;name&apos; AS place_name, -- 将和store中的name键提取出来生成一个新的列 tags-&gt;&apos;tourism&apos; AS tourist_attractionFROM ch03.paris_heteroWHERE GeometryType(geom) = &apos;ST_Point&apos;; 2、使用同构几何列建模使用这种方式，我们会把每个不同的几何类型存储到它自己的一个列或者表中。这种存储方式比异构的更通用。是第三方工具支持最多的一种方式。根据几何类型来区分不同的列或者表，允许你进行强制几何类型约束，防止不经意间的类型的混淆。 下面的代码，将之前的异构的表中的数据拆分成同构的表。 1234567891011121314151617181920-- 创建一个表用于存储点CREATE TABLE ch03.paris_points( gid SERIAL PRIMARY KEY, osm_id integer, ar_num integer, feature_name varchar(200), feature_type varchar(50));-- 注册几何列，约束该几何列只存储点。这个约束是同构方式的关键。SELECT AddGeometryColumn(&apos;ch03&apos;, &apos;paris_points&apos;, &apos;geom&apos;, 32631, &apos;POINT&apos;, 2);-- 从之前的表中，将数据提取出来，插入到新建的表中。INSERT INTO ch03.paris_points( osm_id, ar_num, geom, feature_name, feature_type)SELECT osm_id, ar_num, geom, tags-&gt;&apos;name&apos; AS feature_name, COALESCE(tags-&gt;&apos;tourism&apos;, tags-&gt;&apos;railway&apos;, &apos;other&apos;)::varchar(50) AS feature_typeFROM ch03.paris_heteroWHERE ST_GeometryType(geom) = &apos;ST_Point&apos;; 1234567891011121314151617181920-- 创建一个表用于存储多边形CREATE TABLE ch03.paris_polygons( gid SERIAL PRIMARY KEY, osm_id integer, ar_num integer, feature_name varchar(200), feature_type varchar(50));-- 注册几何列，约束该几何列只存储多边形。这个约束是同构方式的关键。SELECT AddGeometryColumn(&apos;ch03&apos;, &apos;paris_polygons&apos;, &apos;geom&apos;, 32631, &apos;POLYGON&apos;, 2);-- 从之前的表中，将数据提取出来，插入到新建的表中。INSERT INTO ch03.paris_polygons( osm_id, ar_num, geom, feature_name, feature_type)SELECT osm_id, ar_num, geom, tags-&gt;&apos;name&apos; AS feature_name, COALESCE(tags-&gt;&apos;tourism&apos;, tags-&gt;&apos;railway&apos;, &apos;other&apos;)::varchar(50) AS feature_typeFROM ch03.paris_heteroWHERE ST_GeometryType(geom) = &apos;ST_Polygon&apos;; 1234567891011121314151617181920-- 创建一个表用于存储线串CREATE TABLE ch03.paris_linestrings( gid SERIAL PRIMARY KEY, osm_id integer, ar_num integer, feature_name varchar(200), feature_type varchar(50));-- 注册几何列，约束该几何列只存储线串。这个约束是同构方式的关键。SELECT AddGeometryColumn(&apos;ch03&apos;, &apos;paris_linestrings&apos;, &apos;geom&apos;, 32631, &apos;LINESTRING&apos;, 2);-- 从之前的表中，将数据提取出来，插入到新建的表中。INSERT INTO ch03.paris_linestrings( osm_id, ar_num, geom, feature_name, feature_type)SELECT osm_id, ar_num, geom, tags-&gt;&apos;name&apos; AS feature_name, COALESCE(tags-&gt;&apos;tourism&apos;, tags-&gt;&apos;railway&apos;, &apos;other&apos;)::varchar(50) AS feature_typeFROM ch03.paris_heteroWHERE ST_GeometryType(geom) = &apos;ST_LineString&apos;; 下面是和之前的相同的一个例子，查询同一个区域中不同的特征地点的个数： 123456789SELECT ar_num, COUNT(DISTINCT osm_id) AS compteFROM ( SELECT ar_num, osm_id FROM ch03.paris_points UNION ALL SELECT ar_num, osm_id FROM ch03.paris_polygons UNION ALL SELECT ar_num, osm_id FROM ch03.paris_linestrings )AS X -- 这个别名不能少。GROUP BY ar_num; 可以看到，在同构方法时， 需要分别把每个单独的表中的数据都提取出来合并到一起，在进行之后的操作。 UNION和UNION ALL的区别： UNION会隐式的执行去重操作，而UNION ALL不会，是全部合并到一起。如果你知道你的数据集不能或者不需要去重的话，就用UNION ALL吧，它肯定会更快一些。 3、使用表继承建模","link":"/2020/05/16/postgis-in-action-ch3/"},{"title":"Codeforces Round","text":"这场比赛当时有事没有参加，是后面补的。 Div3难度较低，但是由于很久没做过了，两个小时只做了4题。E题写错了，F题看都没看。过后看了题解才过的。 题目链接：Codeforces Round #642 (Div. 3) A. Most Unstable Array题目描述的比较玄乎，但是写几个例子之后就会发现一个很简单的规律，分以下几种情况来说： n&gt;2时：只要把m放到一个随意的中间的位置，其他位置都是0。这样，m这个数会被前后两个0组合到一起计算两次，结果就是2*m。关于是否是最优解的证明就一细说了，可以这样想一下，如果把m拆开分到不同的位置，那么每个数也是最多会被计算两次。 n=2时：把m放到其中一个位置，另一个位置放0。结果是m。 n=1时：结果是0。 代码如下： 12345678910111213141516int main(){// freopen(&quot;in&quot;, &quot;r&quot;, stdin); int T;scanf(&quot;%d&quot;, &amp;T); while(T--){ int n,m;scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if(n==1){ printf(&quot;%d\\n&quot;, 0); }else if(n==2){ printf(&quot;%d\\n&quot;, m); }else { printf(&quot;%d\\n&quot;, 2*m); } } return 0;} B. Two Arrays And Swaps这个题目很好想。只要把数组a按照从小到大排序，数组b从大到小排序。然后把a和b的前k个数交换。再交换的时候要判断一下，如果a中的数比b中的数大的话就不用交换了。 1234567891011121314151617181920212223242526272829int main(){// freopen(&quot;in&quot;, &quot;r&quot;, stdin); int T;scanf(&quot;%d&quot;, &amp;T); while(T--){ int n,k;scanf(&quot;%d%d&quot;, &amp;n, &amp;k); vector&lt;int&gt; a, b; for(int i = 0; i&lt;n; ++i){ int t;scanf(&quot;%d&quot;, &amp;t); a.push_back(t); } for(int i = 0; i&lt;n; ++i){ int t;scanf(&quot;%d&quot;, &amp;t); b.push_back(t); } sort(a.begin(), a.end()); sort(b.begin(), b.end(), [](int x, int y){ return x&gt;y; }); for(int i = 0;i&lt;k; ++i){ if(a[i]&lt;b[i]) swap(a[i], b[i]); } int sum = 0; for(int i = 0;i&lt;n; ++i)sum += a[i]; printf(&quot;%d\\n&quot;, sum); } return 0;} C. Board Moves题意可以理解为：给出一个棋盘，棋盘的每个格子中有一个棋子。然后把所有的棋子都移动到最中间的位置需要多少步。这个题只要画个棋盘的图，然后计算一个样例就找到规律了。从最中间的那个格子往外扩散，每相同的一圈，需要的步数都是相同的，分别是1、2、3…步。这样，只需要数出每一圈有多少个格子，然后将结果加起来即可。 12345678910111213141516using LL = long long;int main(){// freopen(&quot;in&quot;, &quot;r&quot;, stdin); int T;scanf(&quot;%d&quot;, &amp;T); while(T--){ LL n;cin&gt;&gt;n; LL ans = 0, base = 8; for(LL i = 3; i&lt;=n; i+=2){ ans += base * ((i-1)/2); base += 8; } cout&lt;&lt;ans&lt;&lt;endl; } return 0;} 记得用64位，会超int。 D. Constructing the Array题意是给一个n，取值范围[1, 2e5]。然后根据指定的规则构造出一个长度为n的数组，这个数组存在且唯一。输出这个数组。 最开始我还在想这个题是不是有什么trick，想了好久都白给。后来觉得浪费时间太多了，还是想想有没有暴力的方法吧。然后发现用BFS构造出数组不就行了么。遂写之。 最开始想的BFS的思路是：每次把当前的区间加入到队列中，然后根据当前区间确定出一个位置的值。然后再分割成两个子区间，把两个子区间按照一定的顺序加入到BFS队列中。 后来测试时发现，这样并不能保证区间顺序的正确性，还是要使用优先队列，先按照区间长度从大到小，再按照区间左边界从小到大，插入到优先队列中。这样就能保证顺序的正确性了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct node{ int l; int r;};struct cmp{ bool operator()(const node&amp; a, const node&amp; b){ if(a.r-a.l == b.r-b.l)return a.l&gt;b.l; return a.r-a.l&lt;b.r-b.l; }};int main(){// freopen(&quot;in&quot;, &quot;r&quot;, stdin); int T;scanf(&quot;%d&quot;, &amp;T); while(T--){ int n;scanf(&quot;%d&quot;, &amp;n); priority_queue&lt;node, vector&lt;node&gt;, cmp&gt; q; vector&lt;int&gt; ans(n, 0); int cur = 1; q.push({1, n}); while(!q.empty()){ node t = q.top();q.pop(); int mid; if((t.r-t.l+1)%2){ mid = (t.r+t.l)/2; if(mid&gt;t.l){ q.push({t.l, mid-1}); q.push({mid+1, t.r}); } }else{ mid = (t.r+t.l-1)/2; q.push({mid+1, t.r}); if(mid&gt;t.l){ q.push({t.l, mid-1}); } } ans[mid-1] = cur++; } for(auto x:ans){ printf(&quot;%d &quot;, x); } printf(&quot;\\n&quot;); } return 0;} 这里在优先队列的使用方法上卡了一会，这个东西的使用还是不熟练。 我在看高分选手代码时，发现直接使用set&lt; pair&lt;int, pair&lt;int,int&gt;&gt; &gt;就行了。这个我没有用过，不过根据set有序的原理，应该是会先按照pair的first排序，再按照pair的second排序这样子。 E. K-periodic Garland题意：给一个01字符序列，表示一串灯的状态，0表示关，1表示开。然后规定，如果序列中每两个相邻的打开的灯的距离恰好是指定的k的话，那这个灯的序列就是好的。 问：最少需要改变多少个灯的状态，使得序列变为好的。 这个题没有做出来，当时想了一个暴力贪心的方法。但是第二组数据就直接挂了。赛后看了题解和第一名的代码。前者是dp，后者是模拟+贪心+枚举。但是想法都差不多。我选择了后者的思路，感觉他的思路比较优雅。 首先，先这样想，如果最后的序列是好的，那么最后的结果一定是每隔k-1个0就跟着一个1。那么我们就可以可以根据初始和最后的状态，通过一些简单的计算得出需要修改状态的灯的个数。 然后，初始的状态是不变的，这个我们知道。但是最后的状态该怎么确定呢？枚举。我们可以根据最后的状态，把初始的序列分为两个子序列，一个子序列是最后都是1的灯的序列，即每隔k-1个0的序列。另一个子序列就是剩下的灯组成的序列。那么第一个子序列我们可以通过枚举[0,k)为起点，然后每次跳k个位置即可。这样原始的n个灯，每个会被访问一次，复杂度O(N)。 其次，知道最后的状态，那么怎么计算出需要关闭的灯的个数呢？如果用O(N)的时间去遍历一遍，那么总的复杂度会是O(N^2)，显然不行。这里就有一个关键的技巧了。首先我们可以先数出初始状态打开的灯的个数X。在枚举的子序列中，打开的灯的个数Y，关闭的灯的个数Z。并且在最后的状态中，除了我们枚举的子序列，其他位置的灯都应该是关闭的状态。那么在枚举的子序列中，需要把关闭的灯打开（这里先这样认为，后面再说个问题）。枚举的子序列之外的序列，需要全部关闭。则总的操作数应该是：X-Y+Z。-Y是因为这些灯本来就是开着的，不用操作。这样只需要在枚举的过程中维护需要的最小操作数就可以了。 最后，还有个问题：上面所说的X-Y+Z可能会有不必要的操作。例如111100000这个初始序列，最后都是0的且后面没有1的情况，我们没必要再把后面的灯打开了。这个问题的解决办法在代码里看吧。 123456789101112131415161718192021222324252627282930char s[1000005];int main(){// freopen(&quot;in&quot;, &quot;r&quot;, stdin); int T;scanf(&quot;%d&quot;, &amp;T); while(T--){ int n, k;scanf(&quot;%d%d&quot;, &amp;n, &amp;k); scanf(&quot;%s&quot;, s); int ones = 0; for(int i = 0;i&lt;n; ++i) if(s[i] == &apos;1&apos;) ones++; int ans = 1e9; for(int i = 0;i&lt;k; ++i){ int d = 0; for(int j = i; j&lt;n; j+=k){ if(s[j]==&apos;0&apos;)d++; else d--; //注意：这里需要在每次统计枚举的子序列中的灯的状态时，更新一次 //答案。这样能避免上面所说的最后一个问题。 //因为如果后面没有1，全都是0的话，d的值只会增大，不会减小。 //那么就不会导致最优解被覆盖。 d = min(0, d); ans = min(ans, ones+d); } } printf(&quot;%d\\n&quot;, ans); } return 0;} F. Decreasing Heights题意：给一个棋盘，棋盘中的每个格子都一定的高度。我们需要从（1,1）走到（n,m）。走的限制是： 每次只能向右或者向下走。 下一步的格子的高度必须要比当前格子高1个单位。 对于棋盘中的每个格子，可以对其进行操作，只能降低其高度。所有的格子都可以进行操作。 问：想要从（1,1）走到（n,m），需要降低的总的高度是多少。保证存在解。 这个题没做出来，赛后看的题解，直接说解题思路吧。 首先，我们假设棋盘下标是从（0,0）开始的。h[i,j]表示[i,j]这个格子的高度。还是从最终状态来说，如果要从（0,0）走到（i,j）那么一定有：h[i,j] - h[0,0] = i + j。那么如果我们确定了h[0,0]，就相当于是确定了其他格子的高度。这样，跑一遍dp，就能求出到（n,m）的最小代价了。 然后，如何确定h[0,0]呢？我们可以枚举它的值，但是高度的取值范围最大有1e15，显然不可能这样做。既然要枚举，很容易想到的可以从棋盘中某个原始的格子高度来推出(0,0)的高度。接下来证明这个方法的正确性。上面这个思路是基于一个结论：在确定了最终高度后，棋盘中存在某个格子的高度不变。用反正法，假设在确定了最终高度后，棋盘中所有的格子的高度都会被降低。我们需要的其实只是高度差最小，如果是这样的话，肯定存在一定的浪费。我们可以选择降低最少的一个格子，再把它“提高”回来。这样就又得到之前的正确结论。 代码如下： 12345678910111213141516171819202122232425262728293031using ll = long long;ll INF = 1e18;ll a[105][105];int main(){// freopen(&quot;in&quot;, &quot;r&quot;, stdin); int T;scanf(&quot;%d&quot;, &amp;T); while(T--){ int n, m;scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 0;i&lt;n; ++i)for(int j = 0;j&lt;m; ++j) cin&gt;&gt;a[i][j]; ll a00 = a[0][0], ans = INF; for(int l = 0; l&lt;n; ++l)for(int k = 0; k&lt;m; ++k){ //根据矩阵中的每一个高度，暴力枚举a[0][0]的初始值 a[0][0] = a[l][k] - l - k; if(a[0][0]&gt;a00)continue; //从这个位置推[0,0]得到的结果不合法 vector&lt;vector&lt;ll&gt;&gt; d(n, vector&lt;ll&gt;(m, INF)); d[0][0] = a00 - a[0][0]; for(int i = 0;i&lt;n; ++i)for(int j = 0;j&lt;m; ++j){ //dp ll tar = a[0][0] + i + j; if(a[i][j]&lt;tar)continue; //此路不通 if(i&gt;0)d[i][j] = min(d[i][j], d[i-1][j]+a[i][j]-tar); if(j&gt;0)d[i][j] = min(d[i][j], d[i][j-1]+a[i][j]-tar); } ans = min(ans, d[n-1][m-1]); } cout&lt;&lt;ans&lt;&lt;endl; } return 0;}","link":"/2020/05/16/codeforces-round-642/"},{"title":"Chapter1 什么是空间数据库","text":"1、以空间思维思考尽管各种地图网站提供了前所未有的交互式地图，但是使用他们仍然需要用户收集数据点然后放到地图上。使用地图只能依靠用户的视觉感知，当数据量大后，维护起来很麻烦。 空间数据库：是一个定义了用于存储几何对象的特殊数据类型，并且可以存储几何数据到常规数据库表中的数据库。它提供了特殊的函数和索引使得可以通过SQL语句来查询和操作几何数据。空间数据库常常仅用作存储空间数据的容器，但是它能做到的远远不止这些。尽管空间数据库本质上可以不是关系型数据库，但是大部分有名的都是。 空间数据库提供给你两个工具：存储工具和分析工具。 1.介绍几何数据类型二维地图可以通过三种基本几何对象来组成：点、线串、多边形。 仅仅使用这三种对象，你就能在二维空间对任何东西建模。 2、建模空间查询：使用数据库查询的几何函数来回答空间和空间中的对象的相关问题的查询。 3、介绍PostgreSQL和PostGISPostGIS是一个免费开源的库，它使得另一个免费开源的关系型对象数据库PostgreSQL空间可用。选择PostgreSQL作为PostGIS的开发平台的主要原因是：对创建新类型与操作和控制索引操作的易扩展性。 1. PostgreSQL它是一个拥有“皇族血统”的关系型对象数据库系统，可以追溯到关系数据库诞生的时候。独一无二的特性： 支持许多语言来写数据库函数 支持数组（然而Oracle、DB2也支持） 表继承，类似对象的多继承 定义处理多列的聚合函数的能力 还有一些企业级的高级特性。 2. PostGIS将GIS添加到PostgreSQL中。它是由Refractions Research带头的一个项目。支持300多种空间操作、函数、数据类型和空间索引增强实现。PostGIS可以通过包含其他项目支持来增强。OGC：开放式地理空间协会（Open Geospatial Consortium），它的存在是为了标准化地理和空间数据的获取和发布。它有许多的规格来统一：在web服务中获取地理空间数据、地理空间数据的分发格式、查询地理空间数据。 OSGeo：开源地理空间基金会（Open Source Geospatial Foundation），它倡议储备、支持、推销开源工具、免费化GIS数据 4、开始使用PostGIS1、安装此书使用的版本：PostGIS1.3 or higher，PostgreSQL8.2 or higher。在附录B有安装指南。或者中文博客上的安装教程： Windows：PostGIS教程二：PostGIS的安装_数据库_不睡觉的怪叔叔的博客-CSDN博客 CentOS：Linux（centos）中使用源码安装PostGIS_运维_不睡觉的怪叔叔的博客-CSDN博客 在CentOS上编译SFCGAL时遇到了c++: internal compiler error: Killed (program cc1plus这样的错误，最后查到应该是内存不足的原因，通过使用交换分区来解决，百度这个错误就能找到解决办法。手动安装PostGIS的过程很繁琐，需要小心的执行每个安装步骤。 我在我的windows电脑和centos7服务器上都安装了PostgreSQL+PostGIS。不过主要用服务器来运行数据库，使用Windows上面的pgAdmin来做实验。 安装完成后，在Windows上打开pgAdmin4，会在浏览器中打开一个pgAdmin4的页面，设置好服务器、数据库的连接。然后点击选中一个数据库，再点最页面上面的Tools菜单项，选择Query Tool，就会打开一个执行SQL语句的tab。接下来执行： 1SELECT postgis_full_version(); 如果输出了PostGIS依赖的各项插件的版本号，就说明安装成功了。查看PostgreSQL版本的命令是： 1SELECT version(); 注：再接下来的例子中，一般情况下也只会写出执行的SQL语句，而不给出它的输出结果的截图，只是因为太麻烦了。2、使用PostGIS创建几何对象首先以创建一个点为例子： 1SELECT ST_Point(1,2) as MyFirstPoint; 这样就会创建一个一个点(1, 2)。在这里我们并没有指定空间参考系，PostGIS默认空间参考系的是笛卡尔坐标系，也就是我们从小到大学的那种坐标系。但是在实际应用中指定空间参考系是非常重要的。PostGIS中有3000多个空间参考系（我实际查了一下，现在有5757个），由EPSG标准来给每一种参考系指定一个数字编号。可以在这个表中spatial_ref_sys查到，这个表好像是数据库自带的，不过我没有看到默认有这个，我是在之前的练习中导入数据时搞到的。接下来创建另一个点，这次指定了地理关联： 1SELECT ST_SetSRID(ST_Point(-77.036548, 38.895108),4326); 这里使用ST_SetSRID函数指定了这个点是使用4326这个空间参考系，而这个参考系就是我们所知道的经纬度参考系（WGS 84）。 ST_GeomFromText函数提供了一种更通用的，以文本形式来创建几何对象的方法。这个函数相比于ST_Point这种专门的函数，效率慢、精度低。但是好处是更加直观和通用，适用于所有的几何类型： 1SELECT ST_GeomFromText(&apos;POINT(-77.036548 38.895108)&apos;, 4326); 使用这个函数创建几何类型时，文本内容当然不是随意写的，必须按照一定的格式。这个格式叫做WKT(Well-Known Text)几何表示方式。这种格式是OGC标准规定的。在PostGIS中，ST_AsText和ST_GeomFromText提供相反的操作，来实现：几何类型&lt;-&gt;文本的转换。因为几何类型在数据库中是以二进制格式存储的，没有可读性。例如上面创建的对象可能是这个样子的： 10101000020E6100000FD2E6CCD564253C0A93121E692724340 使用ST_AsText或者ST_AsEWKT可以转换为文本格式。这两者之间略有不同，后者会多输出一个空间参考系的编号。 然后我们来创建一个线串： 1SELECT ST_GeomFromText(&apos;LINESTRING(-14 21,0 0,35 26)&apos;) AS MyCheckMark; 可以看到线串就是一些点的序列而已。创建多边形和线串类似，不过多边形需要是一个闭合的线串，或者说是一个环。下面这个语句创建了一个三角形： 1SELECT ST_GeomFromText(&apos;POLYGON((0 1,1 -1,-1 -1,0 1))&apos;) As MyTriangle; 下面这个语句创建了一个心形： 12SELECT ST_GeomFromText(&apos;POLYGON((52 218, 139 82, 262 207, 245 261, 207 267, 153 207, 125 235, 90 270, 55 244, 51 219, 52 218))&apos;) As HeartPolygon; 在多边型的表示中，比线串格式多了一对小括号。因为多边形中可能存在“洞”，所以多边形可能有多条线串。 以上就是创建几何对象的基本操作了。 5、使用实际数据在这一节会讲述如何从两种常见的格式来加载数据： 分隔的ASCII数据 ESRI图形文件数据 这里提一下几何类型和地理类型： 地理类型：必须以经纬度的方式(WSG 84，SRID=4326)存储，距离的度量单位是米。能够使用的PostGIS函数较少，且效率不高。 几何类型：可以以任何支持的空间参考系来存储，度量单位由空间参考系指定。能够使用的PostGIS函数多。 由于度量方式和计算方式不同，有时候必须在这两种类型之间进行转换。 1、加载以逗号分隔的数据数据来源是一些快餐店的数据信息。在开始加载数据之前，需要先创建schema和表来存储数据。 12345678910111213141516171819202122232425CREATE SCHEMA ch01;-- 创建快餐店名字和代号的映射表CREATE TABLE ch01.lu_franchises( franchise_code char(1) PRIMARY KEY, franchise_name varchar(100));-- 插入一些数据INSERT INTO ch01.lu_franchises(franchise_code, franchise_name)VALUES (&apos;b&apos;, &apos;Burger King&apos;), (&apos;c&apos;, &apos;Carl&apos;&apos;s Jr&apos;), (&apos;h&apos;, &apos;Hardee&apos;&apos;s&apos;), (&apos;i&apos;, &apos;In-N-Out&apos;), (&apos;j&apos;, &apos;Jack in the Box&apos;), (&apos;k&apos;, &apos;Kentucky Fried Chicken&apos;), (&apos;m&apos;, &apos;McDonald&apos;&apos;s&apos;), (&apos;p&apos;, &apos;Pizza Hut&apos;), (&apos;t&apos;, &apos;Taco Bell&apos;), (&apos;w&apos;, &apos;Wendy&apos;&apos;s&apos;);-- 创建快餐店位置的表CREATE TABLE ch01.fastfoods( franchise_code char(1) NOT NULL, lat double precision, lon double precision); 其中： schema是数据库实例下一层的一个概念，从逻辑上分割表、视图、函数这些对象。 创建店名和代号的查找表。 加入一些数据。 创建存储地理位置信息的表。 可以使用PostgreSQL的内置函数COPY或者psql的\\copy命令来将数据加载到数据库中。前者可以在任何可以运行SQL语句的客户端上使用，后者只能在psql客户端中使用。 使用COPY函数： 1COPY ch01.fastfoods FROM &apos;/tmp/postgis/ch01/fastfoods.csv&apos; DELIMITER &apos;,&apos;; 使用psql的\\copy命令： 1\\copy ch01.fastfoods from &apos;/data/fastfoods.csv&apos; DELIMITER AS &apos;,&apos; 这里要把路径替换成自己的。数据来源可以从本书网站上去下载。然后给fastfoods表添加一个主键： 1ALTER TABLE ch01.fastfoods ADD COLUMN ff_id SERIAL PRIMARY KEY; 2、空间化平面文件数据首先，先为fastfoods表创建几何对象列： 12345678-- 创建几何对象列SELECT AddGeometryColumn(&apos;ch01&apos;, &apos;fastfoods&apos;, &apos;geom&apos;, 2163, &apos;POINT&apos;, 2);-- 用现有的经纬度数据来创建对应的几何对象UPDATE ch01.fastfoods SET geom = ST_Transform( ST_GeomFromText(&apos;POINT(&apos; || lon || &apos; &apos; || lat || &apos;)&apos;, 4326), 2163);-- 为几何对象创建空间索引CREATE INDEX idx_fastfoods_geom ON ch01.fastfoods USING GIST(geom); 然后，再为fastfoods表创建地理对象列： 12345-- 这里使用PostgeSQL内置的特性来添加新列，而不是前面的AddGeo..函数ALTER TABLE ch01.fastfoods ADD COLUMN geog geography(POINT, 4326);UPDATE ch01.fastfoods SET geog = ST_GeogFromText(&apos;SRID=4326;POINT(&apos; || lon || &apos; &apos; || lat || &apos;)&apos;);CREATE INDEX idx_fastfoods_geog ON ch01.fastfoods USING GIST(geog); 一个良好的习惯，在执行批量加载操作后执行一次清理： 1vacuum analyze ch01.fastfoods; 清理操作会删除掉已经无用的列，并且更新统计信息。如果不显示调用的化，会由服务器上的vacuum守护进程定期清理。为了防止fastfoods表中的店名代号被错误添加或者修改，为它添加约束： 12345ALTER TABLE ch01.fastfoods ADD CONSTRAINT fk_fastfoods_franchise FOREIGN KEY (franchise_code) REFERENCES ch01.lu_franchises(franchise_code) ON UPDATE CASCADE ON DELETE RESTRICT; 这种语句其实不用记住背过，在图形界面下直接就能通过点点点来生成。 3、从空间数据源加载数据最常用的发布空间数据的格式是ESRI的图形文件格式。加载这种文件格式的数据时，在Windows上需要用到PostGIS 2.0 Shapefile and DBF Loader Exporter这个程序，它会随安装PostGIS时一块安装好。打开它后，需要以下几步操作： 点击View connection details设置好PostgreSQL数据库的信息。 在Import tab中点击Add File，选择.shp文件，然后修改schema为ch01和srid为4269。 在Options中把两个选中的选项去掉。 Import。 在Linux上可以使用pgsql安装目录下的shp2pgsql程序来加载： 1shp2pgsql -s 4269 -g geom_4268 /tmp/postgis/ch01/roadtrl020.shp ch01.roads | psql -h localhost -U postgres -p 4096 test 虽然这个命令很长，但是拆解开后还是很好理解的。完成后会在schema ch01创建下一个新表roads，这个表中包含导入的数据。这里指定的是SRID=4269，它和4326非常相似，在大部分情况下是可以替换使用的。接下来要把4269参考系转换为2163的： 1234SELECT AddGeometryColumn(&apos;ch01&apos;, &apos;roads&apos;, &apos;geom&apos;, 2163, &apos;MULTILINESTRING&apos;, 2);UPDATE ch01.roads SET geom = ST_Transform(geom_4268, 2163);SELECT DropGeometryColumn(&apos;ch01&apos;, &apos;roads&apos;, &apos;geom_4268&apos;);CREATE INDEX idx_roads_geom ON ch01.roads USING GIST(geom); 在这里把2163写成了2613，找错误找了贼久，一定要仔细啊。 在加载完成后不要忘记执行一次： 1VACUUM ANALYZE ch01.roads; 在可以在加载的时候选择直接加载为地理类型，在Windows上只需要把Options…中的Load intogeography column选中即可。 在Linux上执行： 1shp2pgsql -G -g geog /tmp/postgis/ch01/roadtrl020.shp ch01.roads_geog | psql -h localhost -U postgres -p 4096 test 和加载为几何类型时非常相似，只有少许改动。 6、使用空间查询分析数据到目前为止我们已经把数据加载到数据库中了，接下来使用标准统计SQL查询来分析数据。 1、邻近查询空间数据库的最常用方式之一就是查询对象的邻近性。接下来是一些练习问题：注：1英里=1609米 1）有多少连锁快餐店在主要的高速公路一英里范围内？注意：ST_DWithin函数对于几何类型和地理类型是都可以使用的。 123456789SELECT ft.franchise_name, COUNT(DISTINCT ff.ff_id) AS tot -- 数出每种快餐店出现了多少次，DISTINCT用于确保同一家店不会被计算两次FROM ch01.fastfoods AS ff INNER JOIN ch01.lu_franchises AS ft -- 非空间连接，根据代号找出对应的快餐店名 ON ff.franchise_code = ft.franchise_code INNER JOIN ch01.roads AS r -- 空间连接，找出在主干高速公路1英里范围内的快餐店 ON ST_DWithin(ff.geom, r.geom, 1069*1)WHERE r.feature LIKE &apos;Principal Highway%&apos; -- 定位主干高速公路GROUP BY ft.franchise_name -- 对查找出的结果，按照快餐店名字分组ORDER BY tot DESC; -- 按照出现次数降序排序 查询的结果如下： 2）哪条高速公路在半英里半径内，有最多数量的快餐店12345678SELECT r.name, COUNT(DISTINCT ff.ff_id) AS tot -- 数出每种快餐店出现了多少次，DISTINCT用于确保同一家店不会被计算两次FROM ch01.fastfoods AS ff INNER JOIN ch01.roads AS r -- 空间连接，找出在主干高速公路半英里范围内的快餐店 ON ST_DWithin(ff.geom, r.geom, 1069*0.5)WHERE r.feature LIKE &apos;Principal Highway%&apos; -- 定位主干高速公路GROUP BY r.name -- 对查找出的结果，按照高速公路名字分组ORDER BY tot DESC -- 按照出现次数降序排序LIMIT 5; -- 这里只给出前5条高速公路 查询的结果如下：结果中的null是没问题的，因为有些高速公路就是没有名字数据的。 2、使用OpenJUMP可视化数据PostGIS除了擅长于实现只查看地图不可能完成的快速空间分析，还可以可视化数据源，创建附加的适用于在地图上标记出关键区域的衍生出的几何对象。在PostGIS中经常用于可视化的一个函数是ST_Buffer。接下来是一个例子，用于找出高速公路US Route 1在MaryLand州这一段中，10英里范围内的Hardee快餐店有几家： 12345SELECT COUNT(DISTINCT ff.ff_id) AS totFROM ch01.fastfoods AS ff INNER JOIN ch01.roads AS r ON ST_DWithin(ff.geom, r.geom, 1609*10)WHERE r.name=&apos;US Route 1&apos; AND ff.franchise_code=&apos;h&apos; AND r.state=&apos;MD&apos;; 结果是3。 后面一些内容需要使用OpenJUMP才有效果，但是OpenJUMOP需要到12章才讲，所以这里先不写了。 7、总结在本章初步认识了空间关系数据库，以及它是怎么嵌入到关系数据库中的。提出了使用空间结构来对真实世界进行建模的思想。展示了PostgreSQL/PostGIS如何用于分析数据的空间模式。给出了几个简单的例子来展示PostGIS的用法。","link":"/2020/05/16/postgis-in-action-ch1/"},{"title":"Chapter2 几何类型","text":"本节会解释PostGIS是如何管理在数据库中存储的几何数据的。 1、PostGIS中的几何列PostGIS对pgsql进行扩展，引入了几何数据类型。并且可以把几何数据类型和pgsql中的原生数据类型同等对待。pgsql有自己原生的几何数据类型，但它们和PostGIS是不兼容的，并且也没有第三方的可视化支持。这些原生几何类型自pgsql诞生起就存在了，但是它们并不遵从OpenGIS联合体的标准，也不支持空间坐标系。 1、geometry_columns表PostGIS使用一个叫做geometry_columns的表来存储在当前数据库中的和几何列相关联的元数据。这些元数据一般是被第三方工具用来收集数据库中的几何层信息的。当被展示到地图应用程序时，空间表中的几何列常常被解释为层或者特征类。这个表中有七列，分别是： f_table_catalog：数据库名 f_table_schema：schema名 f_table_name：表名 f_geometry_column：几何列名 coord_dimension：几何坐标维度-2,3,4维 SRID：空间参考系ID type：几何对象的类型 其中： 坐标维度最多支持到4维，并且第4维并不是空间的，而常常被当做是M(measure)坐标。PostGIS中所有的几何操作都把第四维看做是额外的属性，而不是空间维度。例如时间维度。 SRID是空间参考系标识符，是一个整数，可以在spatial_ref_sys表中查到对应的相关信息，并且它是该表的主键。还有另外一种表示方法叫做SRS ID，由作者名+唯一表示符来表示。例如，SRID=4326表示经纬度空间参考系，使用SRS ID表示法是EPSG:4326。其中EPSG是一个标准组织的名字。即使使用不同的SRID，也不能改变POSTGIS下层空间参考系是矩形笛卡尔系的事实。当处理地理类型时，这个问题会突显出来。在OGC标准中，未知的SRID用0表示。我们也可以自己定义空间参考系然后加入到 spatial_ref_sys表中 type的值可以是：POINT、LINESTRING、PLOYGON、MULTIPOINT、….、GEOMETRY这些。 强烈建议：不要直接修改geometry_columns表。 2、和geometry_columns表交互为了避免直接修改geometry_columns表，PostGIS提供了五个函数来和geometry_columns表交互： AddGeometryColumn：添加一个几何列到指定表中，并且添加相关元信息到eometry_columns表。 DropGeometryTable：删除一个表中的几何列。 UpdateGeometrySRID：更新表中几何列的SRID。例如当写错了SRID时，可以用这个来修正。 Probe_Geometry_Columns：它不会销毁任何geometry_columns表中已经存在的信息，而只是添加有效的条目。不能用于视图。 Populate_Geometry_Columns：比上一个更复杂一点。它通过检查视图和缺少几何约束的表来添加geometry_columns的元数据。如果不带任何参数调用这个，会把geometry_columns表中的内容全部删除，然后重新填充，消耗时间会很长。 到目前为止我们是通过AddGeometryColumn来添加几何列的。尽管不使用它也能添加几何列，但是在PostGIS2.0版本以前，强烈推荐使用这个。因为它不仅会添加几何列，还会自动维护geometry_columns表。如果使用pgsql原生的方法来添加几何列，需要的操作很多，如果忘了一步就会产生麻烦。 2、几何类型全览本节会详细介绍PostGIS中的所有几何类型。 1、什么是几何在本书中，使用几何来表示GIS中使用的泛化的几何形状和PostGIS中的几何数据类型。PostGIS的几何数据类型遵从OpenGIS标准的几何定义。下面以几个例子看一下：首先创建一个表来存储将展示的所有几何对象： 1234CREATE TABLE my_geometries ( id SERIAL NOT NULL PRIMARY KEY, name varchar(20)); 这里没有指定schema，则直接放在public schema中。pgsql的schema搜索默认是从public开始的。 2、点PostGIS中所有的几何类型都是基于笛卡尔坐标系的。例如：2D(X,Y),3D(X,Y,Z),2DM(X,Y,M),3DM(X,Y,Z,M)。M坐标是一个附加的双精度数值型值。它可以存储到几何对象的任何点中。可正可负，并且它的单位不需要和所在的空间参考系有任何关系。目前就有两种类型2DM,3DM。接下来在之前创建的表中添加一个点几何类型列，并且插入几个点： 1234567SELECT AddGeometryColumn(&apos;public&apos;, &apos;my_geometries&apos;, &apos;my_points&apos;, -1, &apos;POINT&apos;, 2);INSERT INTO my_geometries (name,my_points)VALUES (&apos;Home&apos;,ST_GeomFromText(&apos;POINT(0 0)&apos;));INSERT INTO my_geometries (name,my_points)VALUES (&apos;Pizza 1&apos;,ST_GeomFromText(&apos;POINT(1 1)&apos;)) ;INSERT INTO my_geometries (name,my_points)VALUES (&apos;Pizza 2&apos;,ST_GeomFromText(&apos;POINT(1 -1)&apos;)); 添加了三个点到表中。 3、线串线串至少有两个不同的点来定义。线串根据包含的点的维度不同也有四种不同的变形。接下来在表中添加线串的列： 1234567SELECT AddGeometryColumn(&apos;public&apos;, &apos;my_geometries&apos;, &apos;my_linestrings&apos;, -1, &apos;LINESTRING&apos;, 2);INSERT INTO my_geometries (name,my_linestrings)VALUES (&apos;Linestring Open&apos;,ST_GeomFromText(&apos;LINESTRING(0 0,1 1,1 -1)&apos;));INSERT INTO my_geometries (name,my_linestrings)VALUES (&apos;Linestring Closed&apos;,ST_GeomFromText(&apos;LINESTRING(0 0,1 1,1 -1, 0 0)&apos;)); 添加了两条线串到表中，一条开放的，一条闭合的。闭合线串是创建多边形的基础。当描述线串时会有简单和非简单几何对象的概念。除了起止点外，如果线串自身没有相交，那就是简单的，否则是非简单的。ST_IsSimple函数可以来判断是否是简单的。 1SELECT ST_IsSimple(ST_GeomFromText(&apos;LINESTRING(2 0,0 0,1 1,1 -1)&apos;)); 4、多边形多边形是通过我们之前熟悉的其他几何类型组成的。接下来我们创建一个如下图的三角形： 这个三角形由一条闭合的线串+由该线串包围的所有点构成。线串叫做这个多边形的外环。 123SELECT AddGeometryColumn(&apos;public&apos;,&apos;my_geometries&apos;, &apos;my_polygons&apos;,-1,&apos;POLYGON&apos;,2);INSERT INTO my_geometries (name,my_polygons)VALUES (&apos;Triangle&apos;, ST_GeomFromText(&apos;POLYGON((0 0, 1 1, 1 -1, 0 0))&apos;)); 很多情况下，多边形只有一个环，但是多边形是可以有多个来组成的。每个外环可以有0个或多个内环，这些内环构成了多边形的“洞”。接下来创建一个带两个洞的多边形： 其中阴影部分是多边形，空白部分是多边形的洞。 12345INSERT INTO my_geometries (name,my_polygons)VALUES (&apos;Square with 2 holes&apos;, ST_GeomFromText(&apos;POLYGON( (-0.25 -1.25,-0.25 1.25,2.5 1.25,2.5 -1.25,-0.25 -1.25), (2.25 0,1.25 1,1.25 -1,2.25 0),(1 -1,1 1,0 0,1 -1))&apos;)); 因此多边形的文本表示形式中会有多一对小括号。即使你的多边形只有一个环也要加上。对于多边形来说，存在有效性的概念。有效多边形的环应该不相交或者只在不同的点上有相交。 5、容器几何类型这个名字还有待商榷，英文是Collection geometries。想象这么一种情况，假设要把美国的每个州都用几何对象表示出来。那么处理夏威夷的时候就有问题了，因为它是由5个分开的块组成的。如果我们把这一个州用5个多边形来表示，那么存储格式就会很麻烦了。为了解决这个问题，OGC标准和PostGIS都提供了容器几何类型。它将多个分开的几何对象在逻辑上组合起来。对于每一种单独的几何数据类型，都有一个容器类型： point-&gt;multipoints linestring-&gt;multilinestrings polygon-&gt;multipolygons 除了这些还存在一个geometrycollection类型，可以存储任何的几何类型，前提是它们有相同的空间参考系和空间维度。 1）multipoints这个就只是存储多个点的容器而已。使用WKT语法表示multipoints有以下几种类型： 2D：MULTIPOINT(-1 1, 0 0, 2 3) 2DM：MULTIPOINTM(-1 1 4, 0 0 2, 2 3 2) 3D：MULTIPOINT(-1 1 3, 0 0 1, 2 3 1) 3DM：MULTIPOINT(-1 1 3 4, 0 0 1 2, 2 3 1 2) 注意2DM那种是有区别的。另外还有一种格式，以2D为例：MULTIPOINT((-1 1), (0 0), (2 3))。和上面的格式对比，只是对于每一个点都加了一对小括号。以上两种格式在PostGIS中都可以作为输入格式。但是以文本输出格式是不带小括号那种。 2）multilinestrings这个就是存储线串的容器。有以下几种格式： 2D：MULTILINESTRING((0 0,0 1,1 1),(-1 1,-1 -1)) 2DM：MULTILINESTRINGM((0 0 1,0 1 2,1 1 3),(-1 1 1,-1 -1 2)) 3D：MULTILINESTRING((0 0 1,0 1 2,1 1 3),(-1 1 1,-1 -1 2)) 3DM：MULTILINESTRING((0 0 1 1,0 1 1 2,1 1 1 3),(-1 1 1 1,-1 -1 1 2)) 注意这里的小括号是不能省略的，要不就成了点容器了。 对比之前所说过的线串的简单性，multilinestrings也有简单性的概念： 容器中的每个线串都必须是简单的。 容器中的每两个线串之间不相交。 否则就是非简单的。 3）multipolygons在多边形容器的文本表示法中，会有很多的小括号。每对小括号都表示多边形的一个环。然后再有一对小括号表示一个多边形。再有一对小括号表示multipolygons。下面照样是几种表示格式： 2D：MULTIPOLYGON(((2.25 0,1.25 1,1.25 -1,2.25 0)), ((1 -1,1 1,0 0,1 -1))) 2DM：MULTIPOLYGONM(((2.25 0 1,1.25 1 2,1.25 -1 1,2.25 0 1)), ((1 -1 1,1 1 2,0 0 3,1 -1 4)) ) 3D：MULTIPOLYGON(((2.25 0 1,1.25 1 1,1.25 -1 1,2.25 0 1)), ((1 -1 2,1 1 2,0 0 2,1 -1 2)) ) 3DM：MULTIPOLYGON(((2.25 0 1 1,1.25 1 1 2,1.25 -1 1 1,2.25 0 1 1)), ((1 -1 2 1,1 1 2 2,0 0 2 3,1 -1 2 4)) 对比之前所说的多边形的有效性，multipolygons也有有效性的概念： 容器中的每个多边形都必须是有效的。 容器中的每两个多边形不能互相覆盖。在第四章会详细的说覆盖的概念。 4）geometrycollectiongeometrycollection可以包含PostGIS中任何已知的几何类型，目前这里的任何表示单独的几何类型+它们对应的容器几何类型+geometrycollection。并且包含的几何类型不需要是相同的。对于存储来说，这种可以包含任意类型的容器是很棒的。但是对于很多PostGIS的函数来说对这种容器是没有意义的。例如你可以计算多个多边形的面积，但是你不能计算一个线串和一个多边形的面积吧。 geometrycollection起源于作为查询的返回结果，而不是表中预定义好的列。要尽量避免在表设计时使用这个，但是在处理数据时要考虑到它的存在。 下面给出一些例子： 1234567891011121314SELECT ST_AsText(ST_Collect(the_geom))FROM ( SELECT ST_GeomFromText(&apos;MULTIPOINT(-1 1, 0 0, 2 3)&apos;) As the_geom UNION ALL SELECT ST_GeomFromText(&apos;MULTILINESTRING((0 0,0 1,1 1), (-1 1,-1 -1))&apos;) As the_geom UNION ALL SELECT ST_GeomFromText( &apos;POLYGON( (-0.25 -1.25,-0.25 1.25, 2.5 1.25,2.5 -1.25,-0.25 -1.25), (2.25 0,1.25 1,1.25 -1,2.25 0), (1 -1,1 1,0 0,1 -1) )&apos; ) As the_geom) As foo; 以上SQL代码创建了一个geometrycollection，下面是它的输出结果： 12345GEOMETRYCOLLECTION( MULTIPOINT(-1 1,0 0,2 3), MULTILINESTRING((0 0,0 1,1 1),(-1 1,-1 -1)), POLYGON((-0.25 -1.25,-0.25 1.25,2.5 1.25,2.5 -1.25,-0.25 -1.25),(2.25 0,1.25 1,1.25 -1,2.25 0),(1 -1,1 1,0 0,1 -1))) 下面是另外一个例子： 1234567891011121314SELECT ST_AsEWKT(ST_Collect(the_geom)) FROM ( SELECT ST_GeomFromEWKT(&apos;MULTIPOINTM(-1 1 4, 0 0 2, 2 3 2)&apos;) As the_geom UNION ALL SELECT ST_GeomFromEWKT(&apos;MULTILINESTRINGM((0 0 1,0 1 2,1 1 3), (-1 1 1,-1 -1 2))&apos;) As the_geom UNION ALL SELECT ST_GeomFromEWKT( &apos;POLYGONM( (-0.25 -1.25 1,-0.25 1.25 2, 2.5 1.25 3,2.5 -1.25 1,-0.25 -1.25 1), (2.25 0 2,1.25 1 1,1.25 -1 1,2.25 0 2), (1 -1 2,1 1 2,0 0 2,1 -1 2) )&apos; ) As the_geom) As foo; 输出结果为： 12345678GEOMETRYCOLLECTIONM( MULTIPOINTM(-1 1 4,0 0 2,2 3 2), MULTILINESTRINGM((0 0 1,0 1 2,1 1 3),(-1 1 1,-1 -1 2)), POLYGONM( (-0.25 -1.25 1,-0.25 1.25 2,2.5 1.25 3,2.5 -1.25 1,-0.25 -1.25 1), (2.25 0 2,1.25 1 1,1.25 -1 1,2.25 0 2),(1 -1 2,1 1 2,0 0 2,1 -1 2) )) 在第一个例子中是2D的，对应使用ST_AsText和ST_GeomFromText来做序列化和反序列化。在第二个例子中是2DM的，对应使用ST_AsEWKT和ST_GeomFromEWKT来做序列化和反序列化。 这是因为在兼容OGC标准的函数中，ST_AsText和ST_GeomFromText只是被设计为用于2D的。ST_AsEWKT和ST_GeomFromEWKT是PostGIS创建的，可以应用于任何维度的。其中E表示扩展的。使用这种扩展的函数还有另外一个好处是它还会返回它已经的空间参考系的标识符。 geometrycollection的有效性只有一条规则： 容器中的每个元素都是有效的。 不满足这个规则则不是有效的。 6、曲线几何在PostGIS1.3开始，提供了基本的曲线几何的支持。曲线几何是在OGC SQL-MM Part 3规范中引入的。在PostGIS中曲线几何还远不如其他几何类型成熟，并且也没有被广泛支持。自然的陆地特征很少表现为曲线几何，人造的结构和边界确实会有曲线，但是在许多建模例子中，都可以被约等于为直线。在很多情况下，尽管实际情况是曲线，但是使用线串更加合适。因为处理速度往往比精度更重要。 使用曲线几何的一些注意事项： 很少的第三方工具支持曲线几何，无论是开源还是商业的。 PostGIS中许多函数使用的高级空间库GEOS不支持曲线几何。一个应变方法是使用ST_CurveToLine和ST_LineToCurve来做曲线和线串的相互转换，但是这样会丢失一下处理效率和精度。 许多PostGIS函数不支持曲线几何。 曲线几何不被PostGIS支持，所以使用它很可能是有BUG的。不过在后期的版本中很可能会修复许多BUG，并且扩展许多函数。 既然曲线几何有这么多缺点，那么为什么还要使用它呢？有以下几种原因： 可以使用很少的几个点来表示一个曲线几何对象。 许多工具将会引进曲线几何。 PostGIS正在增加对曲线几何的支持。 曲线几何在一些情况下很重要，例如对人造结构进行建模时。 尽管不用曲线几何存储数据，但是使用曲线几何WKT格式作为中间媒介画一个四分之一圆是很有用的，然后可以使用ST_CurveToLine函数来转换成多边形。 简单来说，你可以认为在PostGIS中，曲线几何就是带弧的几何类型。为了创建一个弧，必须有三个不同的点：起点、终点、控制点。控制点用于控制弧的曲率。如下图所示： 1）CIRCULARSTRING由多条弧首尾相连构成了另外一种曲线几何类型circularstring（圆环串），上图就是一个很好的例子。circularstring是所有曲线几何类型中最简单的，仅仅只包含了弧。 下面给出一个创建circularstring的例子： 12345678SELECT AddGeometryColumn (&apos;public&apos;,&apos;my_geometries&apos;, &apos;my_circular_strings&apos;,-1,&apos;CIRCULARSTRING&apos;,2);INSERT INTO my_geometries(name, my_circular_strings)VALUES (&apos;Circle&apos;, ST_GeomFromText(&apos;CIRCULARSTRING(0 0,2 0, 2 2, 0 2, 0 0)&apos;)), (&apos;Half Circle&apos;, ST_GeomFromText(&apos;CIRCULARSTRING(2.5 2.5,4.5 2.5, 4.5 4.5)&apos;)), (&apos;Several Arcs&apos;, ST_GeomFromText(&apos;CIRCULARSTRING(5 5,6 6,4 8, 7 9, 9.5 9.5, 11 12, 12 12)&apos;)); 上面创建的曲线几何对象如下图所示： 下面的代码计算出已曲线表示和已线串表示需要的点的个数： 123456SELECT name, ST_NPoints(my_circular_strings) As cnpoints, ST_NPoints(ST_CurveToLine(my_circular_strings)) As lnpointsFROM my_geometriesWHERE my_circular_strings IS NOT NULL; 结果如下： 2）COMPOUNDCURVES由圆环串（circularstring）和线串以一定序列构成的几何容器，叫做复合曲线。由复合曲线构成的多边形叫做曲线多边形，例如圆角矩形。 下面是一个创建复合曲线的例子： 12345SELECT AddGeometryColumn (&apos;public&apos;,&apos;my_geometries&apos;,&apos;my_compound_curves&apos;, -1,&apos;COMPOUNDCURVE&apos;,2);INSERT INTO my_geometries(name,my_compound_curves)VALUES ( &apos;Road with curve&apos;, ST_GeomFromText(&apos;COMPOUNDCURVE((2 2, 2.5 2.5), CIRCULARSTRING(2.5 2.5,4.5 2.5, 3.5 3.5), (3.5 3.5, 2.5 4.5, 3 5))&apos;)); 创建的复合曲线如下： 3）CURVEPOLYGON曲线多边形是一个使用圆环串作为外环或者内环的多边形。下面是一个创建曲线多边形的例子： 123456789SELECT AddGeometryColumn (&apos;public&apos;,&apos;my_geometries&apos;, &apos;my_curve_polygons&apos;,-1,&apos;CURVEPOLYGON&apos;,2);INSERT INTO my_geometries(name,my_curve_polygons)VALUES (&apos;Solid Circle&apos;, ST_GeomFromText(&apos;CURVEPOLYGON( CIRCULARSTRING(0 0,2 0, 2 2, 0 2, 0 0))&apos;)), (&apos;Circle t hole&apos;, ST_GeomFromText(&apos;CURVEPOLYGON(CIRCULARSTRING(2.5 2.5,4.5 2.5, 4.5 3.5, 2.5 4.5, 2.5 2.5), (3.5 3.5, 3.25 2.25, 4.25 3.25, 3.5 3.5) )&apos;) ), (&apos;T arcish hole&apos;, ST_GeomFromText(&apos;CURVEPOLYGON((-0.5 7, -1 5, 3.5 5.25, -0.5 7), CIRCULARSTRING(0.25 5.5, -0.25 6.5, -0.5 5.75, 0 5.75, 0.25 5.5))&apos;)); 创建的曲线多边形如下： 7、3D几何类型PostGIS可以识别和存储3D几何对象，但是对它的支持还是有很多缺陷的。在之前的例子中我们看到，可以很容易的创建3D的点、线串、多边形等。但是要明白它们是缺乏体积的感知的。它们只是把2D中的点放到了3D空间而已，或者叫做2.5D。 使用3D几何类型的一些注意事项： PostGIS和底层的GEOS库对3D几何类型有很少的支持。例如所有的关系操作符仅仅只是检查相应的2D维度，而完全忽略Z坐标。 上层函数例如求交、求并仅仅部分处理第三维。 空间操作实现的很棒的速度，通过使用边界框索引。不幸的是现在边界框索引还不支持第三维。 3、总结本章所讲的内容： geometry_columns元表 5个和geometry_columns元表交互的函数 点、线串、多边形 点容器、线串容器、多边形容器、几何类型容器 曲线几何和3D几何 在建模的时候不要想太严格的定义。例如，如果看起来、感觉是多边形，那么就把它当做多边形。不要对内环，外环过分担心除非你特别需要。","link":"/2020/05/16/postgis-in-action-ch2/"},{"title":"PostGIS源码学习-开篇","text":"从这篇文章开始，学习PostGIS的源码。有了之前编写PostgreSQL扩展插件那篇文章后，已经了解PostgreSQL插件开发的基本流程了，这对于学习PostGIS的源码核心部分来说已经够用了。 PostGIS源码版本：3.0.1 PostgreSQL版本：10.12 一、基本介绍先看下PostGIS的目录结构： ./ 根目录下的文件基本上都是和配置相关的一些脚本和安装文件 ./deps 额外的依赖项 ./doc 文档目录（我在看源码时，把这个目录删掉了，因为使用全局搜索时这个目录会有很大干扰。而且想要看文档的话，去官网看还更好看一些） ./extensions 用于支持PostgreSQL扩展插件的框架 ./extras 非核心的一些东西，目前不关注这个 ./liblwgeom LWGEOM几何库 ./libpgcommon LWGEOM和PostgreSQL之间的桥梁 ./loader 用于载入PostGIS数据的一些程序 ./postgis PostGIS提供的函数接口的主要代码 ./raster 光栅扩展 ./regress PostgreSQL的回归测试相关内容 ./topology 拓扑扩展相关 ./utils 一些工具脚本，例如升级相关的工具 剩下的目录或者文件基本上就是和配置、构建、安装相关的了，现在不关心那些。后续可以再写一篇文章，来看看autoconf等工具的使用方法。 目前主要学习./liblwgeom、./libpgcommon、./postgis及其涉及到的部分代码。 PostGIS只是PostgreSQL的一个扩展插件，并不是一个完整的独立的程序，它提供的只是一系列的函数、类型和其相关的操作符重载。因此我没想到什么好的学习方法，只能把每个目录下的源码文件，分成几个大致相同的类别，然后一个类别一个类别的去看。 二、准备工作现在我们手里有的只是一份PostGIS的源码，但是如何方便高效的去阅读它是一个问题。 首先，阅读代码的工具我使用的是Source Insight 4，因为之前看libevent代码的时候使用的也是这个，觉得还是挺方便的，所以就继续用它了。 其次，PostGIS源码中有很多的.in文件，这个之后会被配置替换成对应的代码文件。如果是在C代码中包含的头文件是.h，而现在源码中的是.h.in的话，是不能直接跳转到对应的头文件中的，而且里面的内容应该也要根据平台来进行修正。所以我把源码丢到centos7服务器上编译了一下，完成再把子目录中的目标文件删除掉。然后把代码搞到本地，作为要阅读的代码。我还把doc目录给删掉了，理由上面提到过了。即执行了以下命令： 123./configuremakefind ./ -name *.o | xargs rm -f 然后，打开Source Insight创建项目，把源码添加到项目中。 另外，PostGIS有用到PostgreSQL库，我把PostgeSQL库的C语言头文件也拷下来了，在Source Insight中添加头文件包含目录（Options-&gt;Preferences-&gt;Symbol Lookups-&gt;Import Symbols in Current project），这样就能方便的跳转到对应的声明处了（但是还是有点问题，如果是#include “sub/file.h”这样的，还是找不到）。 到此为止，准备工作就做完了，后续可以开始看源码了。 注意：后面的文章需要对PostGIS有点了解，例如PostGIS中的一些基本概念、基本数据类型等要知道一点。","link":"/2020/05/30/read-postgis-code-0/"},{"title":"编写PostgreSQL扩展插件","text":"这篇文章来看一下写一个PostgreSQL的扩展插件的流程。以36进制的一系列相关内容为例。 参考： Writing Postgres Extensions - The Basics - Big elephants https://www.postgresql.org/docs/current/xfunc-c.html#DFUNC 在PostgreSQL中使用或者加载插件是在数据库中执行CREATE EXTENSION命令。要执行这个命令，至少需要两个文件： extension_name.control：告诉PostgreSQL关于这个插件的一些基本信息。 extension–version.sql：插件的SQL脚本文件。 一、函数扩展1、实现36进制转换函数首先实现的插件只包含一个36进制转换的函数，来看一下具体的工作流程。先写出上面提到的两个文件： base36.control 1234# base36 extensioncomment = &apos;base36 datatype&apos;default_version = &apos;0.0.1&apos;relocatable = true base36–0.0.1.sql 123456789101112131415161718192021222324-- complain if script is sourced in psql, rather than via CREATE EXTENSION\\echo Use &quot;CREATE EXTENSION base36&quot; to load this file. \\quitCREATE FUNCTION base36_encode(digits int)RETURNS textLANGUAGE plpgsql IMMUTABLE STRICT AS $$ DECLARE chars char[]; ret varchar; val int; BEGIN chars := ARRAY[ &apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;, &apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;l&apos;,&apos;m&apos;,&apos;n&apos;,&apos;o&apos;,&apos;p&apos;,&apos;q&apos;,&apos;r&apos;,&apos;s&apos;,&apos;t&apos;, &apos;u&apos;,&apos;v&apos;,&apos;w&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos; ]; val := digits; ret := &apos;&apos;; WHILE val != 0 LOOP ret := chars[(val%36)+1] || ret; val := val/36; END LOOP; RETURN(ret); END $$; 这里有两个地方注意下。首先是第二行，这行的作用是防止这个文件被直接当做脚本文件来执行。这个文件只能在使用CREATE EXTENSION命令时被执行。其次是LANGUAGE plpgsql，这个我也没见过，查了一下它也是一种程序语言，叫做过程化SQL语言，是PostgrSQL对SQL语句的扩展。 写完这两个文件后，把他们放到PostgreSQL安装目录下的share/extension目录下就完成了。 当插件内容多了之后，我们在手动把编写的文件复制到指定目录下就很不方便了。PostgreSQL在9.1版本之后为插件安装提供了构建程序：PGXS，使得可以方便的组织插件的源代码、源文件。通过编写一个Makefile文件来实现。 Makefile 1234567EXTENSION = base36 # the extensions nameDATA = base36--0.0.1.sql # script files to install# postgres build stuffPG_CONFIG = pg_configPGXS := $(shell $(PG_CONFIG) --pgxs)include $(PGXS) 把上面三个文件放到一个目录（任意）当中，然后执行make install就能自动的把我们的插件添加到PostgreSQL的目录中了。 执行然make install后，使用psql连接上我们的数据库，简单的测试一下： 12345678postgres=# CREATE EXTENSION base36;CREATE EXTENSIONpostgres=# SELECT base36_encode(123456789)postgres-# ; base36_encode --------------- 21i3v9(1 row) 至此，我们的第一个版本的插件就完成了。 2、增加回归测试PostgreSQL提供了回归测试的功能，在make install后执行make installcheck可以自动跑一遍我们指定的测试用例。现在，来看下如何写测试用例。 我们需要提供测试用例的脚本文件和期望的输出结果文件。分别放在插件项目的sql/和expected/子目录下。 测试脚本文件 sql/base36_test.sql 1234567CREATE EXTENSION base36;SELECT base36_encode(0);SELECT base36_encode(1);SELECT base36_encode(10);SELECT base36_encode(35);SELECT base36_encode(36);SELECT base36_encode(123456789); 然后我们还需要修改Makefile文件，来告诉make命令我们增加了测试用例： Makefile 1234567EXTENSION = base36DATA = base36--0.0.1.sqlREGRESS = base36_testPG_CONFIG = pg_configPGXS := $(shell $(PG_CONFIG) --pgxs)include $(PGXS) 然后执行make install &amp;&amp; make installcheck命令，会输出results/base36_test.out文件，然后在拿这个文件去和expected/base36_test.out文件比对的时候，发现后者不存在，那么我们增加期望输出文件，里面的内容就使用刚才results中输出的内容。 123456789101112131415161718192021222324252627282930313233343536CREATE EXTENSION base36;SELECT base36_encode(0); base36_encode ---------------(1 row)SELECT base36_encode(1); base36_encode --------------- 1(1 row)SELECT base36_encode(10); base36_encode --------------- a(1 row)SELECT base36_encode(35); base36_encode --------------- z(1 row)SELECT base36_encode(36); base36_encode --------------- 10(1 row)SELECT base36_encode(123456789); base36_encode --------------- 21i3v9(1 row) 再次执行make installcheck就会输出： 1234567891011============== dropping database &quot;contrib_regression&quot; ==============DROP DATABASE============== creating database &quot;contrib_regression&quot; ==============CREATE DATABASEALTER DATABASE============== running regression test queries ==============test base36_test ... ok===================== All 1 tests passed. ===================== 注意：这里的回归测试使用的是PostgreSQL的pg_regress程序，使用我们的Makefile文件的话，会去连接PostgreSQL的默认端口5432。如果使用了自定义的端口的话，我不知道怎么增加参数来指定pg_regress连接的端口。只能临时的在Makefile文件中把指定回归测试那一行，取巧的增加了端口参数： 1REGRESS = --port=4096 base36_test 这样操作能行的原因是，我看原来的写法中base36_test这个字符串是放到pg_regress命令的最后一个参数位置。 更：后来在某个地方看到了增加参数的写法，只要再REGRESS前加上一行下面的代码即可： 1REGRESS_OPTS = --port=4096 这个版本的代码中有个bug，0的进制转换并没有输出，这个确实是代码里有问题，修改base36–0.0.1.sql，增加下面的特判： 123IF digits = 0 THEN RETURN (&apos;0&apos;);END IF; 然后修改expected目录下的.out文件中的结果。 3、使用C语言来实现之前使用的是plpgsql来实现的函数，效率比较低。举个例子，我们执行100万次这个函数： 1SELECT i,base36_encode(i) FROM generate_series(1, 1e6::int) i; 在我的服务器上，执行完上面这条命令大约需要7秒的时间。 下面我们来看看如何使用C语言来实现功能，以及它的效率如何。 先写好C语言的代码： base36.c 1234567891011121314151617181920212223#include &quot;postgres.h&quot;#include &quot;fmgr.h&quot;#include &quot;utils/builtins.h&quot;PG_MODULE_MAGIC;PG_FUNCTION_INFO_V1(base36_encode);Datumbase36_encode(PG_FUNCTION_ARGS){ int32 arg = PG_GETARG_INT32(0); char base36[37] = &quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;; char * buffer = palloc(7* sizeof(char)); unsigned int offset = 7; buffer[--offset] = 0; do{ buffer[--offset] = base36[arg % 36]; }while (arg/=36); PG_RETURN_TEXT_P(cstring_to_text(&amp;buffer[offset]));} 首先是三个头文件，它们在PostgreSQL安装目录/include/server/下。 postgres.h：包含了PostgreSQL的许多基础内容。 fmgr.h：提供了PG_GETARG_XX和PG_RETURN_XXX这样的宏。 utils/builtins.h：提供了许多操作PostgreSQL内置数据类型的函数。 然后PG_MODULE_MAGIC是为了提供兼容性的。 PG_FUNCTION_INFO_V1(base36_encode);指定函数的调用约定为Version 1。还有一个调用约定是Version 0。 Datum是PostgreSQL提供的一种C语言数据类型，类似void *。 PG_FUNCTION_ARGS类似C语言的可变参数，可以接受任意个数的参数，通过PG_GETARG_XX宏来获取第几个参数。 palloc是PostgreSQL提供的C语言内存申请函数。在PostgreSQL插件编写中，只使用palloc和pfree，不要使用C语言的malloc和free。并且palloc申请的内存会被自动释放。还有一个申请内存的函数是palloc0，这个会初始化内存为0。 最后一句PG_RETURN_TEXT_P(cstring_to_text(&amp;buffer[offset]));，使用PG_RETURN_XX宏来返回内容给PostgreSQL，cstring_to_text函数用于把C字符串转换成PostgreSQL的text数据类型。 C语言代码写完了，接下来要把它编译链接成.so（动态库）文件。因为代码里用到了PostgreSQL的头文件，所以需要把头文件的搜索目录添加到系统的C头文件搜索目录中： 1export C_INCLUDE_PATH=$C_INCLUDE_PATH:/PostgreSQL_Path/include/server/ 然后使用gcc进行编译链接： 12gcc -fPIC -c base36.cgcc -shared -o base36.so base36.o 接下来要修改之前的文件，来使用刚刚写好的C语言代码生成的动态库。 更：后来发现，不用自己手动去执行编译和链接，Makefile也不用修改，直接执行make &amp;&amp; make install就可以。 base36–0.0.1.sql 12345-- complain if script is sourced in psql, rather than via CREATE EXTENSION\\echo Use &quot;CREATE EXTENSION base36&quot; to load this file. \\quitCREATE FUNCTION base36_encode(digits int) RETURNS textAS &apos;$libdir/base36&apos;LANGUAGE C IMMUTABLE STRICT; 通过执行pg_config --pkglibdir可以查看$libdir是什么。 Makefile 123456789EXTENSION = base36DATA = base36--0.0.1.sqlREGRESS = base36_test#new lineMODULES = base36 PG_CONFIG = pg_configPGXS := $(shell $(PG_CONFIG) --pgxs)include $(PGXS) 然后执行make install &amp;&amp; make installcheck安装插件，再psql连接到数据库，重新创建base36扩展插件。 现在再执行之前的调用100万次函数的SQL语句，大约需要1秒多的时间。 接下来完善一下我们base36_encode函数的代码，增加上对负数的错误处理。在C代码中增加如下内容： 12345678if(arg &lt; 0){ ereport(ERROR,( errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE), errmsg(&quot;negative values are not allowed&quot;), errdetail(&quot;value %d is negative&quot;, arg), errhint(&quot;make it positive&quot;) )); } 然后重新安装和创建插件，测试如下： 1234postgres=# SELECT base36_encode(-10);ERROR: negative values are not allowedDETAIL: value -10 is negativeHINT: make it positive 以上，就完成了一个简单的插件编写了。如果想了解更详细的内容，去查官方的文档：PostgreSQL扩展 二、类型扩展上面一节实现了将十进制数字转换成36进制的函数，接下来看一下如何将base36作为一种数据类型加入到PostgreSQL中。 首先，修改base36–0.0.1.sql文件 123456789101112131415161718-- complain if script is sourced in psql, rather than via CREATE EXTENSION\\echo Use &quot;CREATE EXTENSION base36&quot; to load this file. \\quitCREATE FUNCTION base36_in(cstring)RETURNS base36AS &apos;$libdir/base36&apos;LANGUAGE C IMMUTABLE STRICT;CREATE FUNCTION base36_out(base36)RETURNS cstringAS &apos;$libdir/base36&apos;LANGUAGE C IMMUTABLE STRICT;CREATE TYPE base36( INPUT = base36_in, OUTPUT = base36_out, LIKE = integer); 上面的代码，就是添加新的数据类型所需的最少内容了。 在类型定义中，INPUT和OUTPUT指定了两个函数，这两个函数是用于将36进制文本转换为36进制类型或者反向转换。 LIKE表示让PostgreSQL把base36像整数那样对待。 下面修改C代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &quot;postgres.h&quot;#include &quot;fmgr.h&quot;#include &quot;utils/builtins.h&quot;#include &lt;stdlib.h&gt;PG_MODULE_MAGIC;PG_FUNCTION_INFO_V1(base36_in);Datumbase36_in(PG_FUNCTION_ARGS){ long result; char* str = PG_GETARG_CSTRING(0); result = strtol(str, NULL, 36); PG_RETURN_INT32((int32)result);}PG_FUNCTION_INFO_V1(base36_out);Datumbase36_out(PG_FUNCTION_ARGS){ int32 arg = PG_GETARG_INT32(0); if(arg &lt; 0){ ereport(ERROR,( errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE), errmsg(&quot;negative values are not allowed&quot;), errdetail(&quot;value %d is negative&quot;, arg), errhint(&quot;make it positive&quot;) )); } char base36[37] = &quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;; char * buffer = palloc(7* sizeof(char)); unsigned int offset = 7; buffer[--offset] = 0; do{ buffer[--offset] = base36[arg % 36]; }while (arg/=36); PG_RETURN_CSTRING(&amp;buffer[offset]);} 从代码上可以看到，其实只是把36进制转换成了int32来存储。 写完代码后执行make &amp;&amp; make install，然后测试： 123456789101112test=# CREATE TABLE base36_test(val base36);CREATE TABLEtest=# INSERT INTO base36_test VALUES (&apos;123&apos;), (&apos;3c&apos;), (&apos;5A&apos;), (&apos;zZz&apos;);INSERT 0 4test=# SELECT * FROM base36_test; val----- 123 3c 5a zzz(4 rows) 这样就完成添加新的数据类型。 三、操作符扩展在完成上面的测试后，我们执行下面的SQL语句，将查询到的内容排序输出： 12345postgres=# select * from base36_test order by val;ERROR: could not identify an ordering operator for type base36LINE 1: select * from base36_test order by val; ^HINT: Use an explicit ordering operator or modify the query. 执行出错，提示没有对应的比较操作符。确实应该如此，对于一个新的数据类型，如果我们不给出操作符重载，那么PostgreSQL怎么能知道该如何去比较大小呢。 在base36–0.0.1.sql文件中增加如下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899CREATE FUNCTION base36_eq(base36, base36)RETURNS boolean LANGUAGE internal IMMUTABLE AS &apos;int4eq&apos;;CREATE FUNCTION base36_ne(base36, base36)RETURNS boolean LANGUAGE internal IMMUTABLE AS &apos;int4ne&apos;;CREATE FUNCTION base36_lt(base36, base36)RETURNS boolean LANGUAGE internal IMMUTABLE AS &apos;int4lt&apos;;CREATE FUNCTION base36_le(base36, base36)RETURNS boolean LANGUAGE internal IMMUTABLE AS &apos;int4le&apos;;CREATE FUNCTION base36_gt(base36, base36)RETURNS boolean LANGUAGE internal IMMUTABLE AS &apos;int4gt&apos;;CREATE FUNCTION base36_ge(base36, base36)RETURNS boolean LANGUAGE internal IMMUTABLE AS &apos;int4ge&apos;;CREATE FUNCTION base36_cmp(base36, base36)RETURNS integer LANGUAGE internal IMMUTABLE AS &apos;btint4cmp&apos;;CREATE FUNCTION hash_base36(base36)RETURNS integer LANGUAGE internal IMMUTABLE AS &apos;hashint4&apos;;CREATE OPERATOR = ( LEFTARG = base36, RIGHTARG = base36, PROCEDURE = base36_eq, COMMUTATOR = &apos;=&apos;, NEGATOR = &apos;&lt;&gt;&apos;, RESTRICT = eqsel, JOIN = eqjoinsel, HASHES, MERGES);CREATE OPERATOR &lt;&gt; ( LEFTARG = base36, RIGHTARG = base36, PROCEDURE = base36_ne, COMMUTATOR = &apos;&lt;&gt;&apos;, NEGATOR = &apos;=&apos;, RESTRICT = neqsel, JOIN = neqjoinsel);CREATE OPERATOR &lt; ( LEFTARG = base36, RIGHTARG = base36, PROCEDURE = base36_lt, COMMUTATOR = &gt; , NEGATOR = &gt;= , RESTRICT = scalarltsel, JOIN = scalarltjoinsel);CREATE OPERATOR &lt;= ( LEFTARG = base36, RIGHTARG = base36, PROCEDURE = base36_le, COMMUTATOR = &gt;= , NEGATOR = &gt; , RESTRICT = scalarltsel, JOIN = scalarltjoinsel);CREATE OPERATOR &gt; ( LEFTARG = base36, RIGHTARG = base36, PROCEDURE = base36_gt, COMMUTATOR = &lt; , NEGATOR = &lt;= , RESTRICT = scalargtsel, JOIN = scalargtjoinsel);CREATE OPERATOR &gt;= ( LEFTARG = base36, RIGHTARG = base36, PROCEDURE = base36_ge, COMMUTATOR = &lt;= , NEGATOR = &lt; , RESTRICT = scalargtsel, JOIN = scalargtjoinsel);CREATE OPERATOR CLASS btree_base36_opsDEFAULT FOR TYPE base36 USING btreeAS OPERATOR 1 &lt; , OPERATOR 2 &lt;= , OPERATOR 3 = , OPERATOR 4 &gt;= , OPERATOR 5 &gt; , FUNCTION 1 base36_cmp(base36, base36);CREATE OPERATOR CLASS hash_base36_ops DEFAULT FOR TYPE base36 USING hash AS OPERATOR 1 = , FUNCTION 1 hash_base36(base36); 首先，我们创建了一系列的用于base36的比较函数和操作符。然后把他们放到一个类中，这样就能够在新的数据类型上创建索引了。 另外，我们注意到创建的比较函数使用的都是内置的int的比较函数。 重新安装好后进行测试： 12345postgres=# SELECT &apos;123&apos;::base36 &lt; &apos;23&apos;::base36; ?column? ---------- f(1 row) 接下来看下上面代码中的一些东西： COMMUTATOR ：换向，例如&gt;对应&lt;，&lt;=对应&gt;=。 NEGATOR：否定词，例如&gt;对应&lt;=，&lt;对应&gt;=。 注意：之前的C代码是有bug的，在某些情况下会崩溃。不过这都不重要了，重要的是学习扩展插件的开发过程。","link":"/2020/05/29/write-psql-extension/"},{"title":"PostGIS源码学习-1-lwgeom库之基本类型及其构造","text":"这是PostGIS源码学习正式开始的第一篇，我大致浏览了源码后，发现lwgeom库算是PostGIS的地基。这个库是PostGIS的通用的几何处理部分，包含几何类型、构造/析构（请允许我在C语言中用这两个名词）以及一系列空间处理函数。所以先从这一部分开始。这部分我打算分两篇来写，第一篇看所有的数据类型，以及如何和创建这些类型相关的内容。第二篇看剩下的空间处理函数等。 lwgeom库在源码目录下的liblwgeom目录下。使用这个库的大部分文件中，只需要包含liblwgeom.h这个头文件就行了。这个头文件中包含了该库导出的绝大部分数据类型和相关函数。光这个头文件就有2400多行。所以我们从这个头文件出发，看到感兴趣的一些声明就跳到具体的实现文件中去学习。下面就开始进入源码了。 首先在这个头文件中，开始先是一系列的宏定义：lwgeom库版本号、真/假、成功/失败、几何类型代号、标志位掩码及其设置/读取宏、SRID的最大范围等。这些从宏的名字可读性比较高，看到时通过宏名字就能识别出它的意义。所以这部分就不贴代码了，免得浪费篇幅。 类似其他开源库，lwgeom也提供给用户设置内存管理函数和日志/调试输出的接口： 123456789101112131415//定义一相关的系列函数指针typedef void* (*lwallocator)(size_t size);typedef void* (*lwreallocator)(void *mem, size_t size);typedef void (*lwfreeor)(void* mem);typedef void (*lwreporter)(const char* fmt, va_list ap) __attribute__ (( format(printf, 1, 0) ));typedef void (*lwdebuglogger)(int level, const char* fmt, va_list ap) __attribute__ (( format(printf, 2,0) ));//提供设置内存管理函数的接口extern void lwgeom_set_handlers(lwallocator allocator, lwreallocator reallocator, lwfreeor freeor, lwreporter errorreporter, lwreporter noticereporter);//提供设置输出调试日志的接口extern void lwgeom_set_debuglogger(lwdebuglogger debuglogger); 上面只是给出了函数指针，具体的函数变量是在lwutil.c中定义的： 1234567//默认的内存管理函数，其实只是对C语言的malloc、realloc、free的调用lwallocator lwalloc_var = default_allocator;lwreallocator lwrealloc_var = default_reallocator;lwfreeor lwfree_var = default_freeor;//默认的日志输出只是通过fprintf输出到stderrlwreporter lwnotice_var = default_noticereporter;lwreporter lwerror_var = default_errorreporter; 一、几何类型这一节，先把所有的几何类型的定义列出来，每个几何类型也就是一个结构体。 1、边界框在PostGIS中为了方便创建几何对象的索引，有一个边界框的概念，就是每个几何对象的每个维度坐标的最大值和最小值。这里存在两个类型BOX3D和GBOX，不同的地方是前者只有3个维度并且有存SRID。后者有4个维度和一个标志位变量。我在后面的代码中好像有看到BOX3D是不推荐使用的。 12345678910111213141516171819typedef struct{ double xmin, ymin, zmin; double xmax, ymax, zmax; int32_t srid;}BOX3D;typedef struct{ lwflags_t flags; double xmin; double xmax; double ymin; double ymax; double zmin; double zmax; double mmin; double mmax;} GBOX; 关于m维，后面再说。 2、点类型点，也可以说是PostGIS中的坐标，每个几何类型，都要由一个个的点来表示出来。根据维度的不同，目前点有四种类型： 123456789101112131415161718192021222324typedef struct{ double x, y;}POINT2D;typedef struct{ double x, y, z;}POINT3DZ;typedef struct{ double x, y, z;}POINT3D;typedef struct{ double x, y, m;}POINT3DM;typedef struct{ double x, y, z, m;}POINT4D; 2D、3D都好说。关于4D，第4维度是m，表示meaure，度量。用于存储一些时间之类的信息。 所以在PostGIS中最多只有3维的几何体，第4维是额外的一些度量信息。","link":"/2020/05/31/read-postgis-code-1/"}],"tags":[],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"PostGIS","slug":"PostGIS","link":"/categories/PostGIS/"},{"name":"codeforces","slug":"codeforces","link":"/categories/codeforces/"},{"name":"PostGIS In Action","slug":"PostGIS/PostGIS-In-Action","link":"/categories/PostGIS/PostGIS-In-Action/"},{"name":"PostGIS源码","slug":"PostGIS/PostGIS源码","link":"/categories/PostGIS/PostGIS%E6%BA%90%E7%A0%81/"},{"name":"PostgreSQL","slug":"PostgreSQL","link":"/categories/PostgreSQL/"}]}