{"pages":[],"posts":[{"title":"黎明","text":"终于搭好自己的博客了。之前的工作和学习过程中多多少少也记录了一些东西，但是没有系统的整理，文档东放一个西放一个。从现在开始要养成一个系统的、总结记录的好习惯。 FLAG立个Flag： 每周至少一场Codeforces或者Topcoder，并且在完成后写总结。 每周至少一篇关于学到的新东西的记录。 坚持记录总结工作中遇到的比较通用的问题。 这样也能锻炼一下自己的文字能力，同时也给自己一点压力，逐渐养成一个良好的习惯。","link":"/2020/05/12/Beginning/"},{"title":"Codeforces Round","text":"这场比赛当时有事没有参加，是后面补的。 Div3难度较低，但是由于很久没做过了，两个小时只做了4题。E题写错了，F题看都没看。过后看了题解才过的。 题目链接：Codeforces Round #642 (Div. 3) A. Most Unstable Array题目描述的比较玄乎，但是写几个例子之后就会发现一个很简单的规律，分以下几种情况来说： n&gt;2时：只要把m放到一个随意的中间的位置，其他位置都是0。这样，m这个数会被前后两个0组合到一起计算两次，结果就是2*m。关于是否是最优解的证明就一细说了，可以这样想一下，如果把m拆开分到不同的位置，那么每个数也是最多会被计算两次。 n=2时：把m放到其中一个位置，另一个位置放0。结果是m。 n=1时：结果是0。 代码如下： 12345678910111213141516int main(){// freopen(&quot;in&quot;, &quot;r&quot;, stdin); int T;scanf(&quot;%d&quot;, &amp;T); while(T--){ int n,m;scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if(n==1){ printf(&quot;%d\\n&quot;, 0); }else if(n==2){ printf(&quot;%d\\n&quot;, m); }else { printf(&quot;%d\\n&quot;, 2*m); } } return 0;} B. Two Arrays And Swaps这个题目很好想。只要把数组a按照从小到大排序，数组b从大到小排序。然后把a和b的前k个数交换。再交换的时候要判断一下，如果a中的数比b中的数大的话就不用交换了。 1234567891011121314151617181920212223242526272829int main(){// freopen(&quot;in&quot;, &quot;r&quot;, stdin); int T;scanf(&quot;%d&quot;, &amp;T); while(T--){ int n,k;scanf(&quot;%d%d&quot;, &amp;n, &amp;k); vector&lt;int&gt; a, b; for(int i = 0; i&lt;n; ++i){ int t;scanf(&quot;%d&quot;, &amp;t); a.push_back(t); } for(int i = 0; i&lt;n; ++i){ int t;scanf(&quot;%d&quot;, &amp;t); b.push_back(t); } sort(a.begin(), a.end()); sort(b.begin(), b.end(), [](int x, int y){ return x&gt;y; }); for(int i = 0;i&lt;k; ++i){ if(a[i]&lt;b[i]) swap(a[i], b[i]); } int sum = 0; for(int i = 0;i&lt;n; ++i)sum += a[i]; printf(&quot;%d\\n&quot;, sum); } return 0;} C. Board Moves题意可以理解为：给出一个棋盘，棋盘的每个格子中有一个棋子。然后把所有的棋子都移动到最中间的位置需要多少步。这个题只要画个棋盘的图，然后计算一个样例就找到规律了。从最中间的那个格子往外扩散，每相同的一圈，需要的步数都是相同的，分别是1、2、3…步。这样，只需要数出每一圈有多少个格子，然后将结果加起来即可。 12345678910111213141516using LL = long long;int main(){// freopen(&quot;in&quot;, &quot;r&quot;, stdin); int T;scanf(&quot;%d&quot;, &amp;T); while(T--){ LL n;cin&gt;&gt;n; LL ans = 0, base = 8; for(LL i = 3; i&lt;=n; i+=2){ ans += base * ((i-1)/2); base += 8; } cout&lt;&lt;ans&lt;&lt;endl; } return 0;} 记得用64位，会超int。 D. Constructing the Array题意是给一个n，取值范围[1, 2e5]。然后根据指定的规则构造出一个长度为n的数组，这个数组存在且唯一。输出这个数组。 最开始我还在想这个题是不是有什么trick，想了好久都白给。后来觉得浪费时间太多了，还是想想有没有暴力的方法吧。然后发现用BFS构造出数组不就行了么。遂写之。 最开始想的BFS的思路是：每次把当前的区间加入到队列中，然后根据当前区间确定出一个位置的值。然后再分割成两个子区间，把两个子区间按照一定的顺序加入到BFS队列中。 后来测试时发现，这样并不能保证区间顺序的正确性，还是要使用优先队列，先按照区间长度从大到小，再按照区间左边界从小到大，插入到优先队列中。这样就能保证顺序的正确性了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct node{ int l; int r;};struct cmp{ bool operator()(const node&amp; a, const node&amp; b){ if(a.r-a.l == b.r-b.l)return a.l&gt;b.l; return a.r-a.l&lt;b.r-b.l; }};int main(){// freopen(&quot;in&quot;, &quot;r&quot;, stdin); int T;scanf(&quot;%d&quot;, &amp;T); while(T--){ int n;scanf(&quot;%d&quot;, &amp;n); priority_queue&lt;node, vector&lt;node&gt;, cmp&gt; q; vector&lt;int&gt; ans(n, 0); int cur = 1; q.push({1, n}); while(!q.empty()){ node t = q.top();q.pop(); int mid; if((t.r-t.l+1)%2){ mid = (t.r+t.l)/2; if(mid&gt;t.l){ q.push({t.l, mid-1}); q.push({mid+1, t.r}); } }else{ mid = (t.r+t.l-1)/2; q.push({mid+1, t.r}); if(mid&gt;t.l){ q.push({t.l, mid-1}); } } ans[mid-1] = cur++; } for(auto x:ans){ printf(&quot;%d &quot;, x); } printf(&quot;\\n&quot;); } return 0;} 这里在优先队列的使用方法上卡了一会，这个东西的使用还是不熟练。 我在看高分选手代码时，发现直接使用set&lt; pair&lt;int, pair&lt;int,int&gt;&gt; &gt;就行了。这个我没有用过，不过根据set有序的原理，应该是会先按照pair的first排序，再按照pair的second排序这样子。 E. K-periodic Garland题意：给一个01字符序列，表示一串灯的状态，0表示关，1表示开。然后规定，如果序列中每两个相邻的打开的灯的距离恰好是指定的k的话，那这个灯的序列就是好的。 问：最少需要改变多少个灯的状态，使得序列变为好的。 这个题没有做出来，当时想了一个暴力贪心的方法。但是第二组数据就直接挂了。赛后看了题解和第一名的代码。前者是dp，后者是模拟+贪心+枚举。但是想法都差不多。我选择了后者的思路，感觉他的思路比较优雅。 首先，先这样想，如果最后的序列是好的，那么最后的结果一定是每隔k-1个0就跟着一个1。那么我们就可以可以根据初始和最后的状态，通过一些简单的计算得出需要修改状态的灯的个数。 然后，初始的状态是不变的，这个我们知道。但是最后的状态该怎么确定呢？枚举。我们可以根据最后的状态，把初始的序列分为两个子序列，一个子序列是最后都是1的灯的序列，即每隔k-1个0的序列。另一个子序列就是剩下的灯组成的序列。那么第一个子序列我们可以通过枚举[0,k)为起点，然后每次跳k个位置即可。这样原始的n个灯，每个会被访问一次，复杂度O(N)。 其次，知道最后的状态，那么怎么计算出需要关闭的灯的个数呢？如果用O(N)的时间去遍历一遍，那么总的复杂度会是O(N^2)，显然不行。这里就有一个关键的技巧了。首先我们可以先数出初始状态打开的灯的个数X。在枚举的子序列中，打开的灯的个数Y，关闭的灯的个数Z。并且在最后的状态中，除了我们枚举的子序列，其他位置的灯都应该是关闭的状态。那么在枚举的子序列中，需要把关闭的灯打开（这里先这样认为，后面再说个问题）。枚举的子序列之外的序列，需要全部关闭。则总的操作数应该是：X-Y+Z。-Y是因为这些灯本来就是开着的，不用操作。这样只需要在枚举的过程中维护需要的最小操作数就可以了。 最后，还有个问题：上面所说的X-Y+Z可能会有不必要的操作。例如111100000这个初始序列，最后都是0的且后面没有1的情况，我们没必要再把后面的灯打开了。这个问题的解决办法在代码里看吧。 123456789101112131415161718192021222324252627282930char s[1000005];int main(){// freopen(&quot;in&quot;, &quot;r&quot;, stdin); int T;scanf(&quot;%d&quot;, &amp;T); while(T--){ int n, k;scanf(&quot;%d%d&quot;, &amp;n, &amp;k); scanf(&quot;%s&quot;, s); int ones = 0; for(int i = 0;i&lt;n; ++i) if(s[i] == &apos;1&apos;) ones++; int ans = 1e9; for(int i = 0;i&lt;k; ++i){ int d = 0; for(int j = i; j&lt;n; j+=k){ if(s[j]==&apos;0&apos;)d++; else d--; //注意：这里需要在每次统计枚举的子序列中的灯的状态时，更新一次 //答案。这样能避免上面所说的最后一个问题。 //因为如果后面没有1，全都是0的话，d的值只会增大，不会减小。 //那么就不会导致最优解被覆盖。 d = min(0, d); ans = min(ans, ones+d); } } printf(&quot;%d\\n&quot;, ans); } return 0;} F. Decreasing Heights题意：给一个棋盘，棋盘中的每个格子都一定的高度。我们需要从（1,1）走到（n,m）。走的限制是： 每次只能向右或者向下走。 下一步的格子的高度必须要比当前格子高1个单位。 对于棋盘中的每个格子，可以对其进行操作，只能降低其高度。所有的格子都可以进行操作。 问：想要从（1,1）走到（n,m），需要降低的总的高度是多少。保证存在解。 这个题没做出来，赛后看的题解，直接说解题思路吧。 首先，我们假设棋盘下标是从（0,0）开始的。h[i,j]表示[i,j]这个格子的高度。还是从最终状态来说，如果要从（0,0）走到（i,j）那么一定有：h[i,j] - h[0,0] = i + j。那么如果我们确定了h[0,0]，就相当于是确定了其他格子的高度。这样，跑一遍dp，就能求出到（n,m）的最小代价了。 然后，如何确定h[0,0]呢？我们可以枚举它的值，但是高度的取值范围最大有1e15，显然不可能这样做。既然要枚举，很容易想到的可以从棋盘中某个原始的格子高度来推出(0,0)的高度。接下来证明这个方法的正确性。上面这个思路是基于一个结论：在确定了最终高度后，棋盘中存在某个格子的高度不变。用反正法，假设在确定了最终高度后，棋盘中所有的格子的高度都会被降低。我们需要的其实只是高度差最小，如果是这样的话，肯定存在一定的浪费。我们可以选择降低最少的一个格子，再把它“提高”回来。这样就又得到之前的正确结论。 代码如下： 12345678910111213141516171819202122232425262728293031using ll = long long;ll INF = 1e18;ll a[105][105];int main(){// freopen(&quot;in&quot;, &quot;r&quot;, stdin); int T;scanf(&quot;%d&quot;, &amp;T); while(T--){ int n, m;scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 0;i&lt;n; ++i)for(int j = 0;j&lt;m; ++j) cin&gt;&gt;a[i][j]; ll a00 = a[0][0], ans = INF; for(int l = 0; l&lt;n; ++l)for(int k = 0; k&lt;m; ++k){ //根据矩阵中的每一个高度，暴力枚举a[0][0]的初始值 a[0][0] = a[l][k] - l - k; if(a[0][0]&gt;a00)continue; //从这个位置推[0,0]得到的结果不合法 vector&lt;vector&lt;ll&gt;&gt; d(n, vector&lt;ll&gt;(m, INF)); d[0][0] = a00 - a[0][0]; for(int i = 0;i&lt;n; ++i)for(int j = 0;j&lt;m; ++j){ //dp ll tar = a[0][0] + i + j; if(a[i][j]&lt;tar)continue; //此路不通 if(i&gt;0)d[i][j] = min(d[i][j], d[i-1][j]+a[i][j]-tar); if(j&gt;0)d[i][j] = min(d[i][j], d[i][j-1]+a[i][j]-tar); } ans = min(ans, d[n-1][m-1]); } cout&lt;&lt;ans&lt;&lt;endl; } return 0;}","link":"/2020/05/16/codeforces-round-642/"}],"tags":[{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"codeforces","slug":"codeforces","link":"/tags/codeforces/"}],"categories":[]}